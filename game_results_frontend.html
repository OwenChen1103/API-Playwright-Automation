<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T9 遊戲結果即時監控 - 分桌顯示</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a1a; color: #fff; }
        .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .title { font-size: 2.5rem; font-weight: 600; margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: #888; font-size: 1.1rem; }
        
        .connection-status { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; }
        .status-indicator { width: 12px; height: 12px; border-radius: 50%; background: #ef4444; }
        .status-indicator.connected { background: #4ade80; }
        .status-indicator.connecting { background: #fbbf24; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5a6fd8; }
        .btn-secondary { background: #6b7280; color: white; }
        .btn-secondary:hover { background: #5f656d; }
        .btn-small { padding: 4px 8px; font-size: 0.8rem; }
        
        .controls { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; }
        .table-selector { display: flex; align-items: center; gap: 10px; }
        .table-selector select { 
            padding: 8px 12px; 
            border: 1px solid #444; 
            border-radius: 6px; 
            background: #2a2a2a; 
            color: #fff; 
            min-width: 200px;
        }
        .table-tabs { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 20px; }
        .table-tab { 
            padding: 8px 16px; 
            border: 1px solid #444; 
            border-radius: 6px; 
            background: #2a2a2a; 
            color: #fff; 
            cursor: pointer; 
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        .table-tab:hover { background: #3a3a3a; }
        .table-tab.active { background: #667eea; border-color: #667eea; }
        .table-tab.has-activity { border-left: 4px solid #4ade80; }
        
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 30px; }
        .stat-card { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; padding: 15px; }
        .stat-title { font-size: 0.9rem; color: #888; margin-bottom: 5px; }
        .stat-value { font-size: 1.5rem; font-weight: 600; }
        .stat-value.success { color: #4ade80; }
        .stat-value.warning { color: #fbbf24; }
        .stat-value.error { color: #ef4444; }
        .stat-value.info { color: #60a5fa; }
        .stat-value.banker { color: #ef4444; }
        .stat-value.player { color: #3b82f6; }
        .stat-value.tie { color: #22c55e; }

        .result-statistics { margin-top: 20px; border-top: 1px solid #333; padding-top: 20px; }
        .result-stats { font-size: 0.9rem; color: #bbb; }
        .verify-ok { color: #4ade80; }
        .verify-error { color: #f87171; font-weight: bold; }
        
        .main-content { display: grid; grid-template-columns: 1fr 400px; gap: 20px; height: 70vh; }
        .panel { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; overflow: hidden; }
        .panel-header { background: #333; padding: 15px; font-weight: 600; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center; }
        .panel-content { height: calc(100% - 60px); overflow-y: auto; padding: 15px; }
        
        .game-table { width: 100%; }
        .game-table th, .game-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #333; }
        .game-table th { background: #333; color: #aaa; font-size: 0.9rem; }
        .game-table tr:nth-child(even) { background: #1a1a1a; }
        .game-table tr.fresh { background: #0d4f3c; animation: fadeIn 0.5s ease-in; }
        .game-table tr.in-progress { background: #1a2e3a; }
        .game-table tr.betting { background: #3a2a1a; }
        
        @keyframes fadeIn { from { opacity: 0; background: #1a472a; } to { opacity: 1; background: #0d4f3c; } }
        
        .event-item { margin-bottom: 10px; padding: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; border-left: 4px solid #667eea; }
        .event-item.result { border-left-color: #4ade80; }
        .event-item.error { border-left-color: #ef4444; }
        .event-item.heartbeat { border-left-color: #fbbf24; }
        
        .event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .event-type { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; background: #333; }
        .event-time { font-size: 0.8rem; color: #888; }
        .event-content { font-size: 0.9rem; }
        .event-content pre { background: #111; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 0.8rem; }

        .event-details { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px; }
        .detail-item {
            display: inline-block;
            background: rgba(102, 126, 234, 0.1);
            color: #a3a3f5;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        .error-details .detail-item {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.2);
        }
        
        .badge { padding: 2px 6px; border-radius: 3px; font-size: 0.8rem; }
        .badge-success { background: #166534; color: #86efac; }
        .badge-danger { background: #7f1d1d; color: #fca5a5; }
        .badge-warning { background: #92400e; color: #fbbf24; }
        .badge-info { background: #1e3a8a; color: #93c5fd; }
        .badge-betting { background: #92400e; color: #fed7aa; }
        .badge-in-progress { background: #065f46; color: #6ee7b7; }
        
        .table-overview { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .table-card { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.2s; }
        .table-card:hover { background: #3a3a3a; transform: translateY(-2px); }
        .table-card.active { border-color: #667eea; background: #2a2e3a; }
        .table-card-header { display: flex; justify-content: between; align-items: center; margin-bottom: 10px; }
        .table-card-title { font-size: 1.1rem; font-weight: 600; color: #667eea; }
        .table-card-status { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; }
        .table-card-content { font-size: 0.9rem; }
        .table-card-item { margin-bottom: 5px; }
        
        .hidden { display: none; }

        .points-display {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .banker-points {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .player-points {
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(96, 165, 250, 0.3);
        }
        .points-separator {
            color: #666;
            font-weight: normal;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">T9 遊戲結果即時監控</h1>
        </header>

        <div class="connection-status">
            <div class="status-indicator" id="connectionStatus"></div>
            <span id="connectionText">未連接</span>
            <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">連接</button>
            <button class="btn btn-secondary" onclick="clearResults()">清空結果</button>
            <button class="btn btn-secondary" onclick="resetStats()">重置統計</button>
            <button class="btn btn-secondary" onclick="refreshTables()">刷新桌號</button>
        </div>

        <div class="controls">
            <div class="table-selector">
                <label for="tableSelect">選擇桌號:</label>
                <select id="tableSelect" onchange="switchTable()">
                    <option value="">載入中...</option>
                </select>
            </div>
            <button class="btn btn-secondary btn-small" onclick="toggleOverview()">
                <span id="overviewToggleText">總覽模式</span>
            </button>
        </div>

        <!-- 桌號標籤 -->
        <div class="table-tabs" id="tableTabs"></div>

        <!-- 總覽模式 -->
        <div class="table-overview hidden" id="tableOverview"></div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-title">連接時間</div>
                <div class="stat-value" id="connectionTime">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">監控時長</div>
                <div class="stat-value info" id="monitoringDuration">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">當前桌號</div>
                <div class="stat-value info" id="currentTable">全部</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">總局數</div>
                <div class="stat-value success" id="totalResults">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">活躍桌數</div>
                <div class="stat-value" id="activeTables">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">最後更新</div>
                <div class="stat-value" id="lastUpdate">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">錯誤數</div>
                <div class="stat-value error" id="errorCount">0</div>
            </div>
        </div>

        <!-- 莊閒和統計區域 -->
        <div class="stats result-statistics" id="resultStatistics">
            <div class="stat-card">
                <div class="stat-title">莊勝</div>
                <div class="stat-value banker" id="bankerWins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">閒勝</div>
                <div class="stat-value player" id="playerWins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">和局</div>
                <div class="stat-value tie" id="tieResults">0</div>
            </div>
        </div>

        <div class="main-content" id="detailView">
            <div class="panel">
                <div class="panel-header">
                    <span id="panelTitle">遊戲結果 (最新 30 筆)</span>
                    <button class="btn btn-secondary btn-small" onclick="refreshCurrentTable()">刷新</button>
                </div>
                <div class="panel-content">
                    <table class="game-table" id="gameTable">
                        <thead>
                            <tr>
                                <th>局號</th>
                                <th>桌號</th>
                                <th>開局時間</th>
                                <th>結果</th>
                                <th>點數 (莊/閒)</th>
                                <th>狀態</th>
                            </tr>
                        </thead>
                        <tbody id="gameTableBody">
                            <tr>
                                <td colspan="6" style="text-align: center; color: #888;">等待連接...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">系統事件</div>
                <div class="panel-content" id="eventsList">
                    <div style="text-align: center; color: #888;">等待事件...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 桌號映射表 - 可輕鬆擴展
        const TABLE_MAPPING = {
            'WG7': 'BG_131',
            'WG8': 'BG_132',
            'WG9': 'BG_133',
            'WG10': 'BG_135',
            'WG11': 'BG_136',
            'WG12': 'BG_137',
            'WG13': 'BG_138'
            // 未來可以在此添加更多映射
        };

        // 桌號映射函數
        function mapTableId(originalTableId) {
            if (!originalTableId) return originalTableId;
            return TABLE_MAPPING[originalTableId] || originalTableId;
        }

        // 反向映射函數（用於API調用時需要原始桌號）
        function unmapTableId(displayTableId) {
            if (!displayTableId) return displayTableId;
            for (const [original, display] of Object.entries(TABLE_MAPPING)) {
                if (display === displayTableId) return original;
            }
            return displayTableId;
        }

        let eventSource = null;
        let isConnected = false;
        let connectionStartTime = null;
        let firstResultTime = null;
        let errorCount = 0;
        let gameResults = [];
        let resultTimes = [];
        let availableTables = [];
        let currentTableId = '';
        let isOverviewMode = false;
        let refreshInterval = null;
        let refreshTimeoutId = null;
        let consecutiveErrors = 0;
        let isPageStuck = false;
        let lastActivityTime = Date.now();

        // 監控開始時間（頁面載入時間）
        let monitoringStartTime = Date.now();
        let monitoringDurationInterval = null;

        // Frontend store and deduplication
        const recordStore = new Map(); // key: tableId:roundId, value: { phase, hash, record }

        // Update total games count based on availableTables data
        function updateTotalGamesCount() {
            let totalGames = 0;

            if (currentTableId) {
                // 計算特定桌號的局數
                const targetTable = availableTables.find(table =>
                    String(table.table_id) === String(currentTableId)
                );
                totalGames = targetTable ? (targetTable.total_games || 0) : 0;
            } else {
                // 計算全部桌號的局數 - 直接加總各桌的 total_games
                totalGames = availableTables.reduce((sum, table) => {
                    return sum + (table.total_games || 0);
                }, 0);
            }

            elements.totalResults.textContent = totalGames;
        }

        function updateResultStatistics() {
            let totalStats = {
                banker_wins: 0,
                player_wins: 0,
                ties: 0,
                other: 0
            };

            if (currentTableId) {
                // 特定桌號：使用前端 gameResults 的完整資料（因為已經過濾且獲取了該桌所有歷史）
                const resultsToAnalyze = gameResults.filter(r => String(r.tableId) === String(currentTableId));

                resultsToAnalyze.forEach(result => {
                    const gameResult = result.gameResult;
                    if (gameResult === '莊勝') {
                        totalStats.banker_wins++;
                    } else if (gameResult === '閒勝') {
                        totalStats.player_wins++;
                    } else if (gameResult === '和局') {
                        totalStats.ties++;
                    } else if (gameResult && gameResult !== '進行中' && gameResult !== '投注中' && gameResult !== '開獎中') {
                        totalStats.other++;
                    }
                });

                console.log('[STATS] 特定桌號', currentTableId, '前端資料統計:', totalStats, '總筆數:', resultsToAnalyze.length);
            } else {
                // 全部桌號：使用後端的完整統計數據
                console.log('[STATS DEBUG] availableTables:', availableTables);
                console.log('[STATS DEBUG] availableTables.length:', availableTables.length);

                availableTables.forEach((table, index) => {
                    console.log(`[STATS DEBUG ${index}] Table:`, table.table_id, 'has result_statistics:', !!table.result_statistics);

                    if (table.result_statistics) {
                        console.log(`[STATS DEBUG ${index}] Stats:`, table.result_statistics);
                        totalStats.banker_wins += table.result_statistics.banker_wins || 0;
                        totalStats.player_wins += table.result_statistics.player_wins || 0;
                        totalStats.ties += table.result_statistics.ties || 0;
                        totalStats.other += table.result_statistics.other || 0;
                    } else {
                        console.log(`[STATS DEBUG ${index}] No result_statistics for table:`, table.table_id);
                    }
                });

                console.log('[STATS] 全部桌號後端統計:', totalStats);
                console.log('[STATS] 期望的總和應該接近總局數:', elements.totalResults.textContent);
            }

            // 更新顯示
            elements.bankerWins.textContent = totalStats.banker_wins;
            elements.playerWins.textContent = totalStats.player_wins;
            elements.tieResults.textContent = totalStats.ties;
        }

        const elements = {
            status: document.getElementById('connectionStatus'),
            text: document.getElementById('connectionText'),
            connectBtn: document.getElementById('connectBtn'),
            eventsList: document.getElementById('eventsList'),
            gameTableBody: document.getElementById('gameTableBody'),
            totalResults: document.getElementById('totalResults'),
            lastUpdate: document.getElementById('lastUpdate'),
            errorCount: document.getElementById('errorCount'),
            connectionTime: document.getElementById('connectionTime'),
            monitoringDuration: document.getElementById('monitoringDuration'),
            currentTable: document.getElementById('currentTable'),
            activeTables: document.getElementById('activeTables'),
            bankerWins: document.getElementById('bankerWins'),
            playerWins: document.getElementById('playerWins'),
            tieResults: document.getElementById('tieResults'),
            tableSelect: document.getElementById('tableSelect'),
            tableTabs: document.getElementById('tableTabs'),
            tableOverview: document.getElementById('tableOverview'),
            detailView: document.getElementById('detailView'),
            panelTitle: document.getElementById('panelTitle'),
            overviewToggleText: document.getElementById('overviewToggleText')
        };

        // Phase classification function (matches server-side logic)
        function phaseOf(record) {
            const gameResult = record.gameResult || {};
            const result = (typeof gameResult === 'object' && gameResult.result !== undefined) ? gameResult.result : -1;
            const status = (record.game_payment_status_name || "").trim();

            if ([0, 1, 2, 3].includes(result)) {
                return 3;
            }
            if (['停止', '派彩', '結束'].some(keyword => status.includes(keyword))) {
                return 2;
            }
            return 1;
        }

        // Primary key function for upsert logic
        function getPrimaryKey(record) {
            const tableId = record.table_id || record.tableId || record.table;
            const roundId = record.round_id || record.roundId;

            if (tableId && roundId) {
                return `${tableId}:${parseInt(roundId)}`;
            }
            return null;
        }

        // Apply record with upsert logic
        function applyRecord(record) {
            const primaryKey = getPrimaryKey(record);

            if (!primaryKey) {
                // No primary key, add directly (fallback)
                addGameResultFromData(record);
                return true;
            }

            const phase = phaseOf(record);
            const existing = recordStore.get(primaryKey);

            if (!existing) {
                // New record
                recordStore.set(primaryKey, { phase, record });
                addGameResultFromData(record);
                return true;
            } else {
                // Update existing record (upsert logic)
                // Allow phase progression or same phase with different content
                if (phase >= existing.phase) {
                    recordStore.set(primaryKey, {
                        phase: Math.max(phase, existing.phase),
                        record
                    });
                    addGameResultFromData(record);
                    return true;
                }

                // Phase regression - ignore but log
                console.debug(`[UPSERT] Phase regression ignored: ${primaryKey} (${phase} < ${existing.phase})`);
                return false;
            }
        }

        // Smart refresh with throttling and backoff
        function scheduleNextRefresh() {
            if (refreshTimeoutId) {
                clearTimeout(refreshTimeoutId);
            }

            let delay;
            if (consecutiveErrors === 0) {
                // Normal case: 6-9 seconds random
                delay = 6000 + Math.random() * 3000;
            } else {
                // Backoff case: 15-20 seconds random
                delay = 15000 + Math.random() * 5000;
            }

            refreshTimeoutId = setTimeout(async () => {
                try {
                    await softRefresh();
                    consecutiveErrors = 0; // Reset on success
                    scheduleNextRefresh();
                } catch (error) {
                    consecutiveErrors++;
                    console.error('Soft refresh failed:', error);

                    // Check if page is stuck
                    const now = Date.now();
                    if (now - lastActivityTime > 60000) { // 1 minute of inactivity
                        console.warn('Page appears stuck, triggering reload');
                        window.location.reload();
                    } else {
                        scheduleNextRefresh();
                    }
                }
            }, delay);
        }

        // Soft refresh function
        async function softRefresh() {
            const response = await fetch('http://127.0.0.1:8000/api/latest?limit=30');
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            const records = data.records || [];

            let newCount = 0;
            records.forEach(record => {
                if (applyRecord(record)) {
                    newCount++;
                }
            });

            if (newCount > 0) {
                updateTotalGamesCount();
                updateResultStatistics();
                lastActivityTime = Date.now();
                elements.lastUpdate.textContent = new Date().toLocaleTimeString();
                updateGameTable();
            }

            return newCount;
        }

        async function fetchTables() {
            try {
                const response = await fetch('http://127.0.0.1:8000/api/tables/summary');
                const data = await response.json();
                availableTables = data.tables || [];
                updateTableSelector();
                updateTableTabs();
                updateOverview();
                updateTotalGamesCount();
                updateResultStatistics();
                elements.activeTables.textContent = data.total_tables || 0;
            } catch (error) {
                console.error('獲取桌號失敗:', error);
                addEvent('error', '獲取桌號失敗', { error: error.message });
            }
        }

        function updateTableSelector() {
            const select = elements.tableSelect;
            select.innerHTML = '<option value="">全部桌號</option>';

            // 根據映射後的桌號進行排序
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const option = document.createElement('option');
                option.value = table.table_id; // 保持原始桌號作為 value (用於API調用)
                const displayTableId = mapTableId(table.table_id); // 顯示映射後的桌號
                option.textContent = `${displayTableId} (${table.current_status})`;
                select.appendChild(option);
            });

            if (currentTableId) {
                select.value = currentTableId;
            }
        }

        function updateTableTabs() {
            const tabsContainer = elements.tableTabs;
            tabsContainer.innerHTML = '';
            
            // 全部標籤
            const allTab = document.createElement('div');
            allTab.className = `table-tab ${currentTableId === '' ? 'active' : ''}`;
            allTab.textContent = '全部';
            allTab.onclick = () => switchToTable('');
            tabsContainer.appendChild(allTab);
            
            // 各桌標籤 - 根據映射後的桌號排序
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const tab = document.createElement('div');
                tab.className = `table-tab ${currentTableId === table.table_id ? 'active' : ''}`;
                if (table.current_status === '投注中' || table.current_status === '開獎中') {
                    tab.classList.add('has-activity');
                }
                const displayTableId = mapTableId(table.table_id); // 顯示映射後的桌號
                tab.innerHTML = `
                    <div>${displayTableId}</div>
                    <div style="font-size: 0.7rem; color: #888;">${table.current_status}</div>
                `;
                tab.onclick = () => switchToTable(table.table_id);
                tabsContainer.appendChild(tab);
            });
        }

        function updateOverview() {
            const container = elements.tableOverview;
            container.innerHTML = '';

            // 根據映射後的桌號排序
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const card = document.createElement('div');
                card.className = 'table-card';
                card.onclick = () => {
                    toggleOverview();
                    switchToTable(table.table_id);
                };

                const statusClass = getStatusBadgeClass(table.current_status);
                const displayTableId = mapTableId(table.table_id); // 顯示映射後的桌號

                card.innerHTML = `
                    <div class="table-card-header">
                        <div class="table-card-title">${displayTableId}</div>
                        <span class="badge ${statusClass}">${table.current_status}</span>
                    </div>
                    <div class="table-card-content">
                        <div class="table-card-item"><strong>最新結果:</strong> ${table.latest_result}</div>
                        <div class="table-card-item"><strong>最新局號:</strong> ${table.latest_round_id}</div>
                        <div class="table-card-item"><strong>總局數:</strong> ${table.total_games}</div>
                        ${table.result_statistics ? `
                            <div class="table-card-item">
                                <strong>勝負統計:</strong>
                                <span class="result-stats">
                                    莊 ${table.result_statistics.banker_wins} |
                                    閒 ${table.result_statistics.player_wins} |
                                    和 ${table.result_statistics.ties}
                                    ${table.result_statistics.other > 0 ? ` | 其他 ${table.result_statistics.other}` : ''}
                                </span>
                            </div>
                        ` : ''}
                        <div class="table-card-item"><strong>開局時間:</strong> ${formatTime(table.game_start_time)}</div>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function switchTable() {
            const selectedTable = elements.tableSelect.value;
            switchToTable(selectedTable);
        }

        function switchToTable(tableId) {
            currentTableId = tableId;
            const displayTableId = tableId ? mapTableId(tableId) : '全部';
            elements.currentTable.textContent = displayTableId;
            elements.tableSelect.value = tableId;

            // 更新標籤狀態
            document.querySelectorAll('.table-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            if (tableId === '') {
                document.querySelector('.table-tab:first-child').classList.add('active');
                elements.panelTitle.textContent = '遊戲結果 - 全部桌號 (最新 30 筆)';
            } else {
                // 使用映射後的桌號來查找標籤
                const mappedTableId = mapTableId(tableId);
                const activeTab = Array.from(document.querySelectorAll('.table-tab')).find(tab =>
                    tab.textContent.includes(mappedTableId)
                );
                if (activeTab) activeTab.classList.add('active');
                elements.panelTitle.textContent = `遊戲結果 - ${mappedTableId} (全部資料)`;
            }

            // 更新總局數顯示
            updateTotalGamesCount();
            updateResultStatistics();

            refreshCurrentTable();
        }

        async function refreshCurrentTable() {
            try {
                let url;
                if (currentTableId) {
                    // 特定桌號顯示所有資料
                    url = `http://127.0.0.1:8000/api/tables/${currentTableId}?limit=1000`;
                } else {
                    // 全部桌號仍保持30筆限制
                    url = 'http://127.0.0.1:8000/api/latest?limit=30';
                }

                const response = await fetch(url);
                const data = await response.json();

                gameResults = [];
                const records = data.records || [];

                records.forEach(record => {
                    applyRecord(record);
                });

                updateGameTable();
                updateTotalGamesCount();
                updateResultStatistics();
                addEvent('system', `刷新${currentTableId || '全部'}桌號數據`, {
                    table: currentTableId || '全部',
                    count: records.length
                });

                lastActivityTime = Date.now();

            } catch (error) {
                console.error('刷新數據失敗:', error);
                addEvent('error', '刷新數據失敗', { error: error.message });
                consecutiveErrors++;
            }
        }

        function toggleOverview() {
            isOverviewMode = !isOverviewMode;
            if (isOverviewMode) {
                elements.tableOverview.classList.remove('hidden');
                elements.detailView.classList.add('hidden');
                elements.overviewToggleText.textContent = '詳細模式';
                updateOverview();
            } else {
                elements.tableOverview.classList.add('hidden');
                elements.detailView.classList.remove('hidden');
                elements.overviewToggleText.textContent = '總覽模式';
            }
        }

        function refreshTables() {
            fetchTables();
            addEvent('system', '手動刷新桌號列表', {});
        }

        function toggleConnection() {
            if (isConnected) {
                disconnect();
            } else {
                connect();
            }
        }

        function connect() {
            const url = 'http://127.0.0.1:8000/api/stream?event_types=result,error,heartbeat';
            
            connectionStartTime = Date.now();
            firstResultTime = null;

            elements.status.className = 'status-indicator connecting';
            elements.text.textContent = '連接中...';
            elements.connectBtn.textContent = '取消';

            eventSource = new EventSource(url);

            eventSource.onopen = function() {
                isConnected = true;
                elements.status.className = 'status-indicator connected';
                elements.text.textContent = '已連接';
                elements.connectBtn.textContent = '斷開';

                const connectTime = Date.now() - connectionStartTime;
                elements.connectionTime.textContent = connectTime + 'ms';

                // 重置總局數計數器
                recordStore.clear();
                updateTotalGamesCount();

                addEvent('system', '連接建立', { url: url, connectTime: connectTime });

                // 立即抽取歷史資料到 recordStore
                // 使用 softRefresh 確保抓取全部桌號的最新資料
                softRefresh().then(() => {
                    updateTotalGamesCount();
                    updateGameTable();
                });

                // 開始智能刷新
                scheduleNextRefresh(); // 開始智能刷新調度
                fetchTables(); // 立即獲取一次
            };

            eventSource.addEventListener('result', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleGameResult(data);
                } catch (e) {
                    console.error('解析結果數據失敗:', e);
                }
            });

            eventSource.addEventListener('error', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleError(data);
                } catch (e) {
                    console.error('解析錯誤數據失敗:', e);
                }
            });

            eventSource.addEventListener('heartbeat', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleHeartbeat(data);
                } catch (e) {
                    console.error('解析心跳數據失敗:', e);
                }
            });

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addEvent(data.event_type || 'message', '通用事件', data);
                } catch (e) {
                    console.error('解析通用事件失敗:', e);
                }
            };

            eventSource.onerror = function(event) {
                console.error('SSE 連接錯誤:', event);
                errorCount++;
                elements.errorCount.textContent = errorCount;
                
                if (!isConnected) {
                    elements.status.className = 'status-indicator';
                    elements.text.textContent = '連接失敗';
                    elements.connectBtn.textContent = '重連';
                }
                
                addEvent('error', '連接錯誤', { error: event });
            };
        }

        function disconnect() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            
            if (refreshTimeoutId) {
                clearTimeout(refreshTimeoutId);
                refreshTimeoutId = null;
            }
            
            isConnected = false;
            elements.status.className = 'status-indicator';
            elements.text.textContent = '已斷開';
            elements.connectBtn.textContent = '連接';
            
            addEvent('system', '連接斷開', {});
        }

        function handleGameResult(data) {
            let accepted = 0;
            let tables = new Set();

            const take = (r) => {
                try {
                    if (applyRecord(r)) {
                        accepted++;
                        // 提取桌號資訊
                        const tableId = r.table_id || r.tableId || r.table;
                        if (tableId) tables.add(tableId);
                    }
                } catch (e) {
                    console.error('applyRecord failed:', e);
                }
            };

            // 解析 payload，逐筆採納
            if (data && data.payload) {
                if (data.payload.record) {
                    take(data.payload.record);
                } else if (Array.isArray(data.payload.results)) {
                    data.payload.results.forEach(take);
                } else {
                    // 有些服務會直接把 record 放在 payload 根上
                    take(data.payload);
                }
            }

            // 只有真的有變更，才更新統計與畫面
            if (accepted > 0) {
                updateTotalGamesCount();
                updateResultStatistics();
                lastActivityTime = Date.now();
                elements.lastUpdate.textContent = new Date().toLocaleTimeString();
                updateGameTable();
            }

            // 建立事件資訊
            const eventPayload = {
                latency: data.latency_ms || 'N/A',
                accepted: accepted
            };

            // 如果有桌號資訊，加入到 payload
            if (tables.size > 0) {
                eventPayload.tables = Array.from(tables).join(', ');
            }

            addEvent('result', '收到遊戲結果', eventPayload);

            // 刷新桌號列表（如果有新桌號）
            setTimeout(fetchTables, 1000);
        }

        function handleError(data) {
            errorCount++;
            elements.errorCount.textContent = errorCount;
            addEvent('error', '系統錯誤: ' + (data.payload?.error || '未知錯誤'), data.payload);
        }

        function handleHeartbeat(data) {
            addEvent('heartbeat', '心跳檢測', {
                timestamp: data.payload?.timestamp,
                latency: data.latency_ms || 'N/A'
            });
        }

        function addGameResultFromSSE(result) {
            // Use the new applyRecord function for deduplication
            if (applyRecord(result)) {
                lastActivityTime = Date.now();
                updateGameTable();
            }
        }

        function addGameResultFromData(result) {
            const roundId = result.round_id || result.roundId || result.id || 'N/A';
            const tableId = result.table_id || result.tableId || result.table || 'N/A';
            const startTime = result.game_start_time || result.openTime || result.start_time || 'N/A';

            // 處理遊戲結果
            let gameResult = '進行中';
            const gameResultData = result.gameResult || {};
            const status = (result.game_payment_status_name || '').trim();

            if (typeof gameResultData === 'object' && [1, 2, 3, 0].includes(gameResultData.result)) {
                const resultCode = gameResultData.result;
                if (resultCode === 1) gameResult = '閒勝';
                else if (resultCode === 2) gameResult = '和局';
                else if (resultCode === 0) gameResult = '莊勝';
                else if (resultCode === 3) gameResult = '取消/無效';
            } else if (/(派彩|已彩|結束|finished)/i.test(status)) {
                gameResult = '已派彩'; // 狀態 fallback：若沒有具體結果但狀態顯示已結束
            }

            const payload = {
                roundId,
                tableId,
                startTime,
                result: gameResult,
                resultCode: gameResultData.result || -1,
                status,
                raw: result
            };

            const idx = gameResults.findIndex(
                r => String(r.tableId) === String(tableId) && String(r.roundId) === String(roundId)
            );
            if (idx >= 0) {
                // 更新舊資料（例如把「進行中」更新成「已派彩／莊勝」）
                gameResults[idx] = {
                    roundId,
                    tableId,
                    startTime,
                    gameResult,
                    status: status || '未知',
                    timestamp: Date.now(),
                    raw: result  // Include raw data for points extraction
                };
            } else {
                // 新資料才塞到陣列最前面
                gameResults.unshift({
                    roundId,
                    tableId,
                    startTime,
                    gameResult,
                    status: status || '未知',
                    timestamp: Date.now(),
                    raw: result  // Include raw data for points extraction
                });
            }

            if (gameResults.length > 100) gameResults = gameResults.slice(0, 100);
        }

        function updateGameTable() {
            const tbody = elements.gameTableBody;
            tbody.innerHTML = '';

            if (gameResults.length === 0) {
                const row = tbody.insertRow();
                const cell = row.insertCell(0);
                cell.colSpan = 6;
                cell.style.textAlign = 'center';
                cell.style.color = '#888';
                const displayCurrentTableId = currentTableId ? mapTableId(currentTableId) : null;
                cell.textContent = displayCurrentTableId ? `${displayCurrentTableId} 桌暫無遊戲結果` : '暫無遊戲結果';
                return;
            }

            const filtered = gameResults.filter(r => !currentTableId || String(r.tableId) === String(currentTableId));

            // 依「局號」由大到小（最新在前），保證同桌內排序正確
            filtered.sort((a, b) => (Number(b.roundId) || 0) - (Number(a.roundId) || 0));

            // 根據選擇的桌號決定顯示筆數
            const limited = currentTableId ? filtered : filtered.slice(0, 30);
            const sortedResults = limited;

            sortedResults.forEach((result, index) => {
                const row = tbody.insertRow();

                // 根據狀態添加不同的樣式
                if (result.status === '投注中') {
                    row.className = 'betting';
                } else if (result.status === '開獎中' || result.gameResult === '進行中') {
                    row.className = 'in-progress';
                } else if (index === 0 && (result.gameResult === '莊勝' || result.gameResult === '閒勝' || result.gameResult === '和局')) {
                    row.className = 'fresh'; // 只有最新一筆派彩結果才顯示綠色效果
                }

                row.insertCell(0).textContent = result.roundId;
                row.insertCell(1).textContent = mapTableId(result.tableId); // 顯示映射後的桌號
                row.insertCell(2).textContent = formatTime(result.startTime);
                row.insertCell(3).textContent = result.gameResult;

                // 新增點數欄位
                const pointsCell = row.insertCell(4);
                let bankerPoints = null;
                let playerPoints = null;

                // Debug: log the data structure
                console.debug('[POINTS DEBUG]', 'result object:', result);
                console.debug('[POINTS DEBUG]', 'raw object:', result.raw);

                // 嘗試從多個位置提取點數信息
                if (result.raw) {
                    // 方法1: 直接在 raw 對象中查找 (測試數據格式)
                    if (result.raw.bankerPoints !== undefined && result.raw.playerPoints !== undefined) {
                        bankerPoints = result.raw.bankerPoints;
                        playerPoints = result.raw.playerPoints;
                    }
                    // 方法2: 在 gameResult 對象中查找 (測試數據格式)
                    else if (result.raw.gameResult && typeof result.raw.gameResult === 'object') {
                        const gr = result.raw.gameResult;
                        if (gr.bankerPoints !== undefined && gr.playerPoints !== undefined) {
                            bankerPoints = gr.bankerPoints;
                            playerPoints = gr.playerPoints;
                        }
                        // 方法3: 真實數據格式 - player_point/banker_point
                        else if (gr.player_point !== undefined && gr.banker_point !== undefined &&
                                 gr.player_point !== "" && gr.banker_point !== "" &&
                                 gr.player_point !== "-" && gr.banker_point !== "-") {
                            playerPoints = gr.player_point;
                            bankerPoints = gr.banker_point;
                        }
                        // 方法4: 真實數據格式 - maximum_points
                        else if (gr.player_maximum_points !== undefined && gr.banker_maximum_points !== undefined &&
                                 gr.player_maximum_points !== "" && gr.banker_maximum_points !== "" &&
                                 gr.player_maximum_points !== "-" && gr.banker_maximum_points !== "-") {
                            playerPoints = gr.player_maximum_points;
                            bankerPoints = gr.banker_maximum_points;
                        }
                    }
                }

                if (bankerPoints !== null && playerPoints !== null) {
                    pointsCell.innerHTML = `
                        <div class="points-display">
                            <span class="banker-points">${bankerPoints}</span>
                            <span class="points-separator">/</span>
                            <span class="player-points">${playerPoints}</span>
                        </div>
                    `;
                } else {
                    pointsCell.textContent = '等待點數';
                    pointsCell.style.color = '#888';
                    pointsCell.style.fontSize = '0.85rem';
                }

                const statusCell = row.insertCell(5);
                const statusBadge = document.createElement('span');
                statusBadge.className = 'badge ' + getStatusBadgeClass(result.status);
                statusBadge.textContent = result.status;
                statusCell.appendChild(statusBadge);
            });
        }

        function formatTime(timeStr) {
            if (!timeStr || timeStr === 'N/A') return 'N/A';
            try {
                if (typeof timeStr === 'string' && timeStr.includes(':')) {
                    return timeStr; // 已經是時間格式
                }
                const date = new Date(timeStr);
                return date.toLocaleTimeString();
            } catch (e) {
                return timeStr;
            }
        }

        function getStatusBadgeClass(status) {
            if (status === '已結束' || status === 'finished') return 'badge-success';
            if (status === '投注中') return 'badge-betting';
            if (status === '開獎中' || status === '進行中' || status === 'running') return 'badge-in-progress';
            if (status === '錯誤' || status === 'error') return 'badge-danger';
            return 'badge-warning';
        }

        function formatEventPayload(type, payload) {
            if (!payload || Object.keys(payload).length === 0) return '';

            switch (type) {
                case 'result':
                    return `
                        <div class="event-details">
                            ${payload.latency !== 'N/A' ? `<span class="detail-item">延遲: ${payload.latency}ms</span>` : ''}
                            ${payload.accepted ? `<span class="detail-item">接受: ${payload.accepted} 筆</span>` : ''}
                            ${payload.tables ? `<span class="detail-item">桌號: ${payload.tables.split(', ').map(t => mapTableId(t)).join(', ')}</span>` : ''}
                        </div>
                    `;

                case 'system':
                    let systemDetails = '';
                    if (payload.table) {
                        const displayTable = payload.table === '全部' ? '全部' : mapTableId(payload.table);
                        systemDetails += `<span class="detail-item">桌號: ${displayTable}</span>`;
                    }
                    if (payload.count) systemDetails += `<span class="detail-item">數量: ${payload.count}</span>`;
                    if (payload.url) systemDetails += `<span class="detail-item">連接: ${payload.url}</span>`;
                    if (payload.connectTime) systemDetails += `<span class="detail-item">耗時: ${payload.connectTime}ms</span>`;
                    return systemDetails ? `<div class="event-details">${systemDetails}</div>` : '';

                case 'heartbeat':
                    let heartbeatDetails = '';
                    if (payload.timestamp) {
                        try {
                            const time = new Date(payload.timestamp * 1000).toLocaleTimeString();
                            heartbeatDetails += `<span class="detail-item">時間: ${time}</span>`;
                        } catch (e) {
                            heartbeatDetails += `<span class="detail-item">時間: ${payload.timestamp}</span>`;
                        }
                    }
                    if (payload.latency && payload.latency !== 'N/A') {
                        heartbeatDetails += `<span class="detail-item">延遲: ${payload.latency}ms</span>`;
                    }
                    return heartbeatDetails ? `<div class="event-details">${heartbeatDetails}</div>` : '';

                case 'error':
                    return `
                        <div class="event-details error-details">
                            ${payload.error ? `<span class="detail-item">錯誤: ${payload.error}</span>` : ''}
                        </div>
                    `;

                default:
                    // 對於其他類型，簡化顯示重要字段
                    const importantFields = ['status', 'count', 'message', 'success'];
                    let defaultDetails = '';
                    for (const field of importantFields) {
                        if (payload[field] !== undefined) {
                            defaultDetails += `<span class="detail-item">${field}: ${payload[field]}</span>`;
                        }
                    }
                    return defaultDetails ? `<div class="event-details">${defaultDetails}</div>` : '';
            }
        }

        function addEvent(type, title, payload) {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item ' + type;

            const now = new Date();
            const timeStr = now.toLocaleTimeString();

            eventItem.innerHTML = `
                <div class="event-header">
                    <span class="event-type">${type}</span>
                    <span class="event-time">${timeStr}</span>
                </div>
                <div class="event-content">
                    <strong>${title}</strong>
                    ${formatEventPayload(type, payload)}
                </div>
            `;

            elements.eventsList.insertBefore(eventItem, elements.eventsList.firstChild);

            // 只保留最新 20 個事件
            while (elements.eventsList.children.length > 20) {
                elements.eventsList.removeChild(elements.eventsList.lastChild);
            }
        }

        function clearResults() {
            gameResults = [];
            updateGameTable();
            elements.eventsList.innerHTML = '<div style="text-align: center; color: #888;">事件已清空</div>';
        }

        function resetStats() {
            errorCount = 0;
            resultTimes = [];
            firstResultTime = null;
            gameResults = [];
            recordStore.clear();

            updateTotalGamesCount();
            updateResultStatistics();
            elements.errorCount.textContent = '0';
            elements.lastUpdate.textContent = '--';

            // 重置監控時間
            resetMonitoringTimer();

            updateGameTable();
            clearResults();
        }

        // 格式化時間長度
        function formatDuration(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) {
                return `${days}天 ${hours % 24}時 ${minutes % 60}分`;
            } else if (hours > 0) {
                return `${hours}時 ${minutes % 60}分 ${seconds % 60}秒`;
            } else if (minutes > 0) {
                return `${minutes}分 ${seconds % 60}秒`;
            } else {
                return `${seconds}秒`;
            }
        }

        // 更新監控時長
        function updateMonitoringDuration() {
            const duration = Date.now() - monitoringStartTime;
            elements.monitoringDuration.textContent = formatDuration(duration);
        }

        // 啟動監控時長定時器
        function startMonitoringTimer() {
            if (monitoringDurationInterval) {
                clearInterval(monitoringDurationInterval);
            }
            monitoringDurationInterval = setInterval(updateMonitoringDuration, 1000);
            updateMonitoringDuration(); // 立即更新一次
        }

        // 重置監控時間（可選功能）
        function resetMonitoringTimer() {
            monitoringStartTime = Date.now();
            updateMonitoringDuration();
        }

        // 頁面載入時啟動監控定時器
        startMonitoringTimer();

        // 自動連接
        setTimeout(() => {
            if (!isConnected) {
                connect();
            }
        }, 1000);
    </script>
</body>
</html>