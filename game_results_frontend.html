<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T9 遊戲結果即時監控 - 分桌顯示</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a1a; color: #fff; }
        .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .title { font-size: 2.5rem; font-weight: 600; margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: #888; font-size: 1.1rem; }
        
        .connection-status { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; }
        .status-indicator { width: 12px; height: 12px; border-radius: 50%; background: #ef4444; }
        .status-indicator.connected { background: #4ade80; }
        .status-indicator.connecting { background: #fbbf24; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5a6fd8; }
        .btn-secondary { background: #6b7280; color: white; }
        .btn-secondary:hover { background: #5f656d; }
        .btn-small { padding: 4px 8px; font-size: 0.8rem; }
        
        .controls { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; }
        .table-selector { display: flex; align-items: center; gap: 10px; }
        .table-selector select { 
            padding: 8px 12px; 
            border: 1px solid #444; 
            border-radius: 6px; 
            background: #2a2a2a; 
            color: #fff; 
            min-width: 200px;
        }
        .table-tabs { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 20px; }
        .table-tab { 
            padding: 8px 16px; 
            border: 1px solid #444; 
            border-radius: 6px; 
            background: #2a2a2a; 
            color: #fff; 
            cursor: pointer; 
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        .table-tab:hover { background: #3a3a3a; }
        .table-tab.active { background: #667eea; border-color: #667eea; }
        .table-tab.has-activity { border-left: 4px solid #4ade80; }
        
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 30px; }
        .stat-card { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; padding: 15px; }
        .stat-title { font-size: 0.9rem; color: #888; margin-bottom: 5px; }
        .stat-value { font-size: 1.5rem; font-weight: 600; }
        .stat-value.success { color: #4ade80; }
        .stat-value.warning { color: #fbbf24; }
        .stat-value.error { color: #ef4444; }
        .stat-value.info { color: #60a5fa; }
        .stat-value.banker { color: #ef4444; }
        .stat-value.player { color: #3b82f6; }
        .stat-value.tie { color: #22c55e; }

        .result-statistics { margin-top: 20px; border-top: 1px solid #333; padding-top: 20px; }
        .result-stats { font-size: 0.9rem; color: #bbb; }
        .verify-ok { color: #4ade80; }
        .verify-error { color: #f87171; font-weight: bold; }
        
        .main-content { display: grid; grid-template-columns: 1fr 400px; gap: 20px; height: 70vh; }
        .panel { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; overflow: hidden; }
        .panel-header { background: #333; padding: 15px; font-weight: 600; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center; }
        .panel-content { height: calc(100% - 60px); overflow-y: auto; padding: 15px; }
        
        .game-table { width: 100%; }
        .game-table th, .game-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #333; }
        .game-table th { background: #333; color: #aaa; font-size: 0.9rem; }
        .game-table tr:nth-child(even) { background: #1a1a1a; }
        .game-table tr.fresh { background: #0d4f3c; animation: fadeIn 0.5s ease-in; }
        .game-table tr.in-progress { background: #1a2e3a; }
        .game-table tr.betting { background: #3a2a1a; }
        
        @keyframes fadeIn { from { opacity: 0; background: #1a472a; } to { opacity: 1; background: #0d4f3c; } }
        
        .event-item { margin-bottom: 10px; padding: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; border-left: 4px solid #667eea; }
        .event-item.result { border-left-color: #4ade80; }
        .event-item.error { border-left-color: #ef4444; }
        .event-item.heartbeat { border-left-color: #fbbf24; }
        
        .event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .event-type { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; background: #333; }
        .event-time { font-size: 0.8rem; color: #888; }
        .event-content { font-size: 0.9rem; }
        .event-content pre { background: #111; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 0.8rem; }

        .event-details { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px; }
        .detail-item {
            display: inline-block;
            background: rgba(102, 126, 234, 0.1);
            color: #a3a3f5;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        .error-details .detail-item {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.2);
        }
        
        .badge { padding: 2px 6px; border-radius: 3px; font-size: 0.8rem; }
        .badge-success { background: #166534; color: #86efac; }
        .badge-danger { background: #7f1d1d; color: #fca5a5; }
        .badge-warning { background: #92400e; color: #fbbf24; }
        .badge-info { background: #1e3a8a; color: #93c5fd; }
        .badge-betting { background: #92400e; color: #fed7aa; }
        .badge-in-progress { background: #065f46; color: #6ee7b7; }
        
        .table-overview { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .table-card { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.2s; }
        .table-card:hover { background: #3a3a3a; transform: translateY(-2px); }
        .table-card.active { border-color: #667eea; background: #2a2e3a; }
        .table-card-header { display: flex; justify-content: between; align-items: center; margin-bottom: 10px; }
        .table-card-title { font-size: 1.1rem; font-weight: 600; color: #667eea; }
        .table-card-status { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; }
        .table-card-content { font-size: 0.9rem; }
        .table-card-item { margin-bottom: 5px; }
        
        .hidden { display: none; }

        .points-display {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .banker-points {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .player-points {
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(96, 165, 250, 0.3);
        }
        .points-separator {
            color: #666;
            font-weight: normal;
        }

        /* ===== 導出模態框樣式 ===== */
        .export-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .export-modal.hidden {
            display: none;
        }

        .export-modal-content {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { opacity: 0; transform: scale(0.9) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .export-modal-header {
            background: #333;
            padding: 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
        }

        .export-modal-header h2 {
            margin: 0;
            color: #667eea;
            font-size: 1.4rem;
        }

        .export-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .export-modal-close:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        .export-modal-body {
            padding: 20px;
        }

        .export-section {
            margin-bottom: 25px;
        }

        .export-section h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* 格式選擇樣式 */
        .format-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .format-option {
            cursor: pointer;
        }

        .format-option input[type="radio"] {
            display: none;
        }

        .format-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .format-option input[type="radio"]:checked + .format-card {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .format-card:hover {
            border-color: #555;
            background: #252525;
        }

        .format-option input[type="radio"]:checked + .format-card:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.15);
        }

        .format-icon {
            font-size: 24px;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }

        .format-info {
            flex: 1;
        }

        .format-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .format-desc {
            font-size: 0.85rem;
            color: #888;
        }

        /* 篩選條件樣式 */
        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .filter-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-item label {
            font-size: 0.9rem;
            color: #ccc;
            font-weight: 500;
        }

        .filter-item select,
        .filter-item input {
            padding: 10px 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        .filter-item select:focus,
        .filter-item input:focus {
            outline: none;
            border-color: #667eea;
        }

        /* 預覽資訊樣式 */
        .export-preview {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }

        .preview-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .preview-item:last-child {
            margin-bottom: 0;
        }

        .preview-label {
            font-size: 0.9rem;
            color: #888;
            flex: 1;
        }

        .preview-value {
            font-weight: 600;
            color: #4ade80;
            font-size: 0.9rem;
        }

        /* 模態框底部 */
        .export-modal-footer {
            background: #333;
            padding: 20px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            border-radius: 0 0 12px 12px;
        }

        .export-modal-footer .btn {
            min-width: 100px;
        }

        /* 載入動畫 */
        .spinner {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">T9 遊戲結果即時監控</h1>
        </header>

        <div class="connection-status">
            <div class="status-indicator" id="connectionStatus"></div>
            <span id="connectionText">未連接</span>
            <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">連接</button>
            <button class="btn btn-secondary" onclick="confirmClearResults()">清空結果</button>
            <button class="btn btn-secondary" onclick="confirmResetStats()">重置統計</button>
            <button class="btn btn-secondary" onclick="refreshTables()">刷新桌號</button>
        </div>

        <div class="controls">
            <div class="table-selector">
                <label for="tableSelect">選擇桌號:</label>
                <select id="tableSelect" onchange="switchTable()">
                    <option value="">載入中...</option>
                </select>
            </div>
            <button class="btn btn-secondary btn-small" onclick="toggleOverview()">
                <span id="overviewToggleText">總覽模式</span>
            </button>
            <button class="btn btn-primary btn-small" onclick="openExportModal()" title="導出資料">
                📊 導出資料
            </button>
        </div>

        <!-- 桌號標籤 -->
        <div class="table-tabs" id="tableTabs"></div>

        <!-- 總覽模式 -->
        <div class="table-overview hidden" id="tableOverview"></div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-title">連接時間</div>
                <div class="stat-value" id="connectionTime">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">監控時長</div>
                <div class="stat-value info" id="monitoringDuration">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">當前桌號</div>
                <div class="stat-value info" id="currentTable">全部</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">總局數</div>
                <div class="stat-value success" id="totalResults">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">活躍桌數</div>
                <div class="stat-value" id="activeTables">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">最後更新</div>
                <div class="stat-value" id="lastUpdate">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">錯誤數</div>
                <div class="stat-value error" id="errorCount">0</div>
            </div>
        </div>

        <!-- 莊閒和統計區域 -->
        <div class="stats result-statistics" id="resultStatistics">
            <div class="stat-card">
                <div class="stat-title">莊勝</div>
                <div class="stat-value banker" id="bankerWins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">閒勝</div>
                <div class="stat-value player" id="playerWins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">和局</div>
                <div class="stat-value tie" id="tieResults">0</div>
            </div>
        </div>

        <div class="main-content" id="detailView">
            <div class="panel">
                <div class="panel-header">
                    <span id="panelTitle">遊戲結果 (最新 30 筆)</span>
                    <button class="btn btn-secondary btn-small" onclick="refreshCurrentTable()">刷新</button>
                </div>
                <div class="panel-content">
                    <table class="game-table" id="gameTable">
                        <thead>
                            <tr>
                                <th>局號</th>
                                <th>桌號</th>
                                <th>開局時間</th>
                                <th>結果</th>
                                <th>點數 (莊/閒)</th>
                                <th>狀態</th>
                            </tr>
                        </thead>
                        <tbody id="gameTableBody">
                            <tr>
                                <td colspan="6" style="text-align: center; color: #888;">等待連接...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">系統事件</div>
                <div class="panel-content" id="eventsList">
                    <div style="text-align: center; color: #888;">等待事件...</div>
                </div>
            </div>
        </div>

        <!-- 導出資料模態框 -->
        <div id="exportModal" class="export-modal hidden">
            <div class="export-modal-content">
                <div class="export-modal-header">
                    <h2>📊 導出資料</h2>
                    <button class="export-modal-close" onclick="closeExportModal()">&times;</button>
                </div>

                <div class="export-modal-body">
                    <!-- 導出格式選擇 -->
                    <div class="export-section">
                        <h3>1. 選擇格式</h3>
                        <div class="format-options">
                            <label class="format-option">
                                <input type="radio" name="exportFormat" value="json" checked>
                                <div class="format-card">
                                    <div class="format-icon">📄</div>
                                    <div class="format-info">
                                        <div class="format-title">JSON</div>
                                        <div class="format-desc">結構化資料，適合程式處理</div>
                                    </div>
                                </div>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="exportFormat" value="csv">
                                <div class="format-card">
                                    <div class="format-icon">📈</div>
                                    <div class="format-info">
                                        <div class="format-title">CSV</div>
                                        <div class="format-desc">Excel 可開啟，適合分析</div>
                                    </div>
                                </div>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="exportFormat" value="excel">
                                <div class="format-card">
                                    <div class="format-icon">📊</div>
                                    <div class="format-info">
                                        <div class="format-title">Excel</div>
                                        <div class="format-desc">多工作表，功能完整</div>
                                    </div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- 篩選條件 -->
                    <div class="export-section">
                        <h3>2. 篩選條件</h3>
                        <div class="filter-grid">
                            <div class="filter-item">
                                <label for="exportTableId">桌號:</label>
                                <select id="exportTableId">
                                    <option value="">全部桌號</option>
                                </select>
                            </div>
                            <div class="filter-item">
                                <label for="exportStartDate">開始日期:</label>
                                <input type="date" id="exportStartDate">
                            </div>
                            <div class="filter-item">
                                <label for="exportEndDate">結束日期:</label>
                                <input type="date" id="exportEndDate">
                            </div>
                            <div class="filter-item">
                                <label for="exportStatus">狀態篩選:</label>
                                <select id="exportStatus">
                                    <option value="">全部狀態</option>
                                    <option value="投注中">投注中</option>
                                    <option value="開獎中">開獎中</option>
                                    <option value="已結束">已結束</option>
                                    <option value="已派彩">已派彩</option>
                                </select>
                            </div>
                            <div class="filter-item">
                                <label for="exportLimit">筆數限制:</label>
                                <select id="exportLimit">
                                    <option value="">不限制</option>
                                    <option value="100">100 筆</option>
                                    <option value="500">500 筆</option>
                                    <option value="1000">1000 筆</option>
                                    <option value="5000">5000 筆</option>
                                    <option value="10000">10000 筆</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- 預覽資訊 -->
                    <div class="export-section">
                        <h3>3. 預覽資訊</h3>
                        <div class="export-preview">
                            <div class="preview-item">
                                <span class="preview-label">將導出:</span>
                                <span class="preview-value" id="exportPreviewCount">計算中...</span>
                            </div>
                            <div class="preview-item">
                                <span class="preview-label">桌號範圍:</span>
                                <span class="preview-value" id="exportPreviewTables">--</span>
                            </div>
                            <div class="preview-item">
                                <span class="preview-label">檔案大小預估:</span>
                                <span class="preview-value" id="exportPreviewSize">--</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="export-modal-footer">
                    <button class="btn btn-secondary" onclick="closeExportModal()">取消</button>
                    <button class="btn btn-primary" onclick="startExport()" id="exportButton">
                        <span id="exportButtonText">開始導出</span>
                        <span id="exportButtonSpinner" class="spinner hidden">⟳</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 桌號映射表 - 可輕鬆擴展
        const TABLE_MAPPING = {
            'WG7': 'BG_131',
            'WG8': 'BG_132',
            'WG9': 'BG_133',
            'WG10': 'BG_135',
            'WG11': 'BG_136',
            'WG12': 'BG_137',
            'WG13': 'BG_138'
            // 未來可以在此添加更多映射
        };

        // 桌號映射函數
        function mapTableId(originalTableId) {
            if (!originalTableId) return originalTableId;
            return TABLE_MAPPING[originalTableId] || originalTableId;
        }

        // 反向映射函數（用於API調用時需要原始桌號）
        function unmapTableId(displayTableId) {
            if (!displayTableId) return displayTableId;
            for (const [original, display] of Object.entries(TABLE_MAPPING)) {
                if (display === displayTableId) return original;
            }
            return displayTableId;
        }

        let eventSource = null;
        let isConnected = false;
        let connectionStartTime = null;
        let firstResultTime = null;
        let errorCount = 0;
        let gameResults = [];
        let resultTimes = [];
        let availableTables = [];
        let currentTableId = '';
        let isOverviewMode = false;
        let refreshInterval = null;
        let refreshTimeoutId = null;
        let consecutiveErrors = 0;
        let isPageStuck = false;
        let lastActivityTime = Date.now();

        // 監控開始時間（連接成功後才開始計時）
        let monitoringStartTime = null;
        let monitoringDurationInterval = null;

        // 更新活動時間的通用函數
        function updateActivityTime() {
            lastActivityTime = Date.now();
        }

        // 監聽用戶交互事件以更新活動時間
        document.addEventListener('click', updateActivityTime);
        document.addEventListener('keydown', updateActivityTime);
        document.addEventListener('scroll', updateActivityTime);
        document.addEventListener('mousemove', updateActivityTime);

        // Frontend store and deduplication
        const recordStore = new Map(); // key: tableId:roundId, value: { phase, hash, record }

        // Update total games count based on availableTables data
        function updateTotalGamesCount() {
            let totalGames = 0;

            if (currentTableId) {
                // 計算特定桌號的局數
                const targetTable = availableTables.find(table =>
                    String(table.table_id) === String(currentTableId)
                );
                totalGames = targetTable ? (targetTable.total_games || 0) : 0;
            } else {
                // 計算全部桌號的局數 - 直接加總各桌的 total_games
                totalGames = availableTables.reduce((sum, table) => {
                    return sum + (table.total_games || 0);
                }, 0);
            }

            elements.totalResults.textContent = totalGames;
        }

        function updateResultStatistics() {
            let totalStats = {
                banker_wins: 0,
                player_wins: 0,
                ties: 0,
                other: 0
            };

            if (currentTableId) {
                // 特定桌號：使用前端 gameResults 的完整資料（因為已經過濾且獲取了該桌所有歷史）
                const resultsToAnalyze = gameResults.filter(r => String(r.tableId) === String(currentTableId));

                resultsToAnalyze.forEach(result => {
                    const gameResult = result.gameResult;
                    if (gameResult === '莊勝') {
                        totalStats.banker_wins++;
                    } else if (gameResult === '閒勝') {
                        totalStats.player_wins++;
                    } else if (gameResult === '和局') {
                        totalStats.ties++;
                    } else if (gameResult && gameResult !== '進行中' && gameResult !== '投注中' && gameResult !== '開獎中') {
                        totalStats.other++;
                    }
                });

                console.log('[STATS] 特定桌號', currentTableId, '前端資料統計:', totalStats, '總筆數:', resultsToAnalyze.length);
            } else {
                // 全部桌號：使用後端的完整統計數據
                console.log('[STATS DEBUG] availableTables:', availableTables);
                console.log('[STATS DEBUG] availableTables.length:', availableTables.length);

                availableTables.forEach((table, index) => {
                    console.log(`[STATS DEBUG ${index}] Table:`, table.table_id, 'has result_statistics:', !!table.result_statistics);

                    if (table.result_statistics) {
                        console.log(`[STATS DEBUG ${index}] Stats:`, table.result_statistics);
                        totalStats.banker_wins += table.result_statistics.banker_wins || 0;
                        totalStats.player_wins += table.result_statistics.player_wins || 0;
                        totalStats.ties += table.result_statistics.ties || 0;
                        totalStats.other += table.result_statistics.other || 0;
                    } else {
                        console.log(`[STATS DEBUG ${index}] No result_statistics for table:`, table.table_id);
                    }
                });

                console.log('[STATS] 全部桌號後端統計:', totalStats);
                console.log('[STATS] 期望的總和應該接近總局數:', elements.totalResults.textContent);
            }

            // 更新顯示
            elements.bankerWins.textContent = totalStats.banker_wins;
            elements.playerWins.textContent = totalStats.player_wins;
            elements.tieResults.textContent = totalStats.ties;
        }

        const elements = {
            status: document.getElementById('connectionStatus'),
            text: document.getElementById('connectionText'),
            connectBtn: document.getElementById('connectBtn'),
            eventsList: document.getElementById('eventsList'),
            gameTableBody: document.getElementById('gameTableBody'),
            totalResults: document.getElementById('totalResults'),
            lastUpdate: document.getElementById('lastUpdate'),
            errorCount: document.getElementById('errorCount'),
            connectionTime: document.getElementById('connectionTime'),
            monitoringDuration: document.getElementById('monitoringDuration'),
            currentTable: document.getElementById('currentTable'),
            activeTables: document.getElementById('activeTables'),
            bankerWins: document.getElementById('bankerWins'),
            playerWins: document.getElementById('playerWins'),
            tieResults: document.getElementById('tieResults'),
            tableSelect: document.getElementById('tableSelect'),
            tableTabs: document.getElementById('tableTabs'),
            tableOverview: document.getElementById('tableOverview'),
            detailView: document.getElementById('detailView'),
            panelTitle: document.getElementById('panelTitle'),
            overviewToggleText: document.getElementById('overviewToggleText')
        };

        // Phase classification function (matches server-side logic)
        function phaseOf(record) {
            const gameResult = record.gameResult || {};
            const result = (typeof gameResult === 'object' && gameResult.result !== undefined) ? gameResult.result : -1;
            const status = (record.game_payment_status_name || "").trim();

            if ([0, 1, 2, 3].includes(result)) {
                return 3;
            }
            if (['停止', '派彩', '結束'].some(keyword => status.includes(keyword))) {
                return 2;
            }
            return 1;
        }

        // Primary key function for upsert logic
        function getPrimaryKey(record) {
            const tableId = record.table_id || record.tableId || record.table;
            const roundId = record.round_id || record.roundId;

            if (tableId && roundId) {
                return `${tableId}:${parseInt(roundId)}`;
            }
            return null;
        }

        // Apply record with upsert logic
        function applyRecord(record) {
            const primaryKey = getPrimaryKey(record);

            if (!primaryKey) {
                // No primary key, add directly (fallback)
                addGameResultFromData(record);
                return true;
            }

            const phase = phaseOf(record);
            const existing = recordStore.get(primaryKey);

            if (!existing) {
                // New record
                recordStore.set(primaryKey, { phase, record });
                addGameResultFromData(record);
                return true;
            } else {
                // Update existing record (upsert logic)
                // Allow phase progression or same phase with different content
                if (phase >= existing.phase) {
                    recordStore.set(primaryKey, {
                        phase: Math.max(phase, existing.phase),
                        record
                    });
                    addGameResultFromData(record);
                    return true;
                }

                // Phase regression - ignore but log
                console.debug(`[UPSERT] Phase regression ignored: ${primaryKey} (${phase} < ${existing.phase})`);
                return false;
            }
        }

        // Smart refresh with throttling and backoff
        function scheduleNextRefresh() {
            if (refreshTimeoutId) {
                clearTimeout(refreshTimeoutId);
            }

            let delay;
            if (consecutiveErrors === 0) {
                // Normal case: 6-9 seconds random
                delay = 6000 + Math.random() * 3000;
            } else {
                // Backoff case: 15-20 seconds random
                delay = 15000 + Math.random() * 5000;
            }

            refreshTimeoutId = setTimeout(async () => {
                try {
                    await softRefresh();
                    consecutiveErrors = 0; // Reset on success
                    scheduleNextRefresh();
                } catch (error) {
                    consecutiveErrors++;
                    console.error('Soft refresh failed:', error);

                    // Check if page is stuck (extended timeout and better conditions)
                    const now = Date.now();
                    const timeSinceLastActivity = now - lastActivityTime;
                    const timeSincePageLoad = monitoringStartTime ? (now - monitoringStartTime) : 0;

                    // Only check for stuck page if:
                    // 1. Page has been running for at least 5 minutes
                    // 2. No activity for more than 10 minutes
                    // 3. Not currently connected or in error state
                    if (timeSincePageLoad > 300000 && // 5 minutes since page load
                        timeSinceLastActivity > 600000 && // 10 minutes of inactivity
                        !isConnected && // not currently connected
                        consecutiveErrors > 10) { // many consecutive errors
                        console.warn('Page appears stuck after extended inactivity, triggering reload');
                        console.log(`Time since last activity: ${(timeSinceLastActivity/1000/60).toFixed(1)} minutes`);
                        console.log(`Consecutive errors: ${consecutiveErrors}`);
                        window.location.reload();
                    } else {
                        scheduleNextRefresh();
                    }
                }
            }, delay);
        }

        // Soft refresh function
        async function softRefresh() {
            const response = await fetch('http://127.0.0.1:8000/api/latest?limit=30');
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            const records = data.records || [];

            let newCount = 0;
            records.forEach(record => {
                if (applyRecord(record)) {
                    newCount++;
                }
            });

            if (newCount > 0) {
                updateTotalGamesCount();
                updateResultStatistics();
                lastActivityTime = Date.now();
                elements.lastUpdate.textContent = new Date().toLocaleTimeString();
                updateGameTable();
            }

            return newCount;
        }

        async function fetchTables() {
            try {
                const response = await fetch('http://127.0.0.1:8000/api/tables/summary');
                const data = await response.json();
                availableTables = data.tables || [];
                updateTableSelector();
                updateTableTabs();
                updateOverview();
                updateTotalGamesCount();
                updateResultStatistics();
                elements.activeTables.textContent = data.total_tables || 0;
            } catch (error) {
                console.error('獲取桌號失敗:', error);
                addEvent('error', '獲取桌號失敗', { error: error.message });
            }
        }

        function updateTableSelector() {
            const select = elements.tableSelect;
            select.innerHTML = '<option value="">全部桌號</option>';

            // 根據映射後的桌號進行排序
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const option = document.createElement('option');
                option.value = table.table_id; // 保持原始桌號作為 value (用於API調用)
                const displayTableId = mapTableId(table.table_id); // 顯示映射後的桌號
                option.textContent = `${displayTableId} (${table.current_status})`;
                select.appendChild(option);
            });

            if (currentTableId) {
                select.value = currentTableId;
            }
        }

        function updateTableTabs() {
            const tabsContainer = elements.tableTabs;
            tabsContainer.innerHTML = '';
            
            // 全部標籤
            const allTab = document.createElement('div');
            allTab.className = `table-tab ${currentTableId === '' ? 'active' : ''}`;
            allTab.textContent = '全部';
            allTab.onclick = () => switchToTable('');
            tabsContainer.appendChild(allTab);
            
            // 各桌標籤 - 根據映射後的桌號排序
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const tab = document.createElement('div');
                tab.className = `table-tab ${currentTableId === table.table_id ? 'active' : ''}`;
                if (table.current_status === '投注中' || table.current_status === '開獎中') {
                    tab.classList.add('has-activity');
                }
                const displayTableId = mapTableId(table.table_id); // 顯示映射後的桌號
                tab.innerHTML = `
                    <div>${displayTableId}</div>
                    <div style="font-size: 0.7rem; color: #888;">${table.current_status}</div>
                `;
                tab.onclick = () => switchToTable(table.table_id);
                tabsContainer.appendChild(tab);
            });
        }

        function updateOverview() {
            const container = elements.tableOverview;
            container.innerHTML = '';

            // 根據映射後的桌號排序
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const card = document.createElement('div');
                card.className = 'table-card';
                card.onclick = () => {
                    toggleOverview();
                    switchToTable(table.table_id);
                };

                const statusClass = getStatusBadgeClass(table.current_status);
                const displayTableId = mapTableId(table.table_id); // 顯示映射後的桌號

                card.innerHTML = `
                    <div class="table-card-header">
                        <div class="table-card-title">${displayTableId}</div>
                        <span class="badge ${statusClass}">${table.current_status}</span>
                    </div>
                    <div class="table-card-content">
                        <div class="table-card-item"><strong>最新結果:</strong> ${table.latest_result}</div>
                        <div class="table-card-item"><strong>最新局號:</strong> ${table.latest_round_id}</div>
                        <div class="table-card-item"><strong>總局數:</strong> ${table.total_games}</div>
                        ${table.result_statistics ? `
                            <div class="table-card-item">
                                <strong>勝負統計:</strong>
                                <span class="result-stats">
                                    莊 ${table.result_statistics.banker_wins} |
                                    閒 ${table.result_statistics.player_wins} |
                                    和 ${table.result_statistics.ties}
                                    ${table.result_statistics.other > 0 ? ` | 其他 ${table.result_statistics.other}` : ''}
                                </span>
                            </div>
                        ` : ''}
                        <div class="table-card-item"><strong>開局時間:</strong> ${formatTime(table.game_start_time)}</div>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function switchTable() {
            const selectedTable = elements.tableSelect.value;
            switchToTable(selectedTable);
        }

        function switchToTable(tableId) {
            currentTableId = tableId;
            const displayTableId = tableId ? mapTableId(tableId) : '全部';
            elements.currentTable.textContent = displayTableId;
            elements.tableSelect.value = tableId;

            // 更新標籤狀態
            document.querySelectorAll('.table-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            if (tableId === '') {
                document.querySelector('.table-tab:first-child').classList.add('active');
                elements.panelTitle.textContent = '遊戲結果 - 全部桌號 (最新 30 筆)';
            } else {
                // 使用映射後的桌號來查找標籤
                const mappedTableId = mapTableId(tableId);
                const activeTab = Array.from(document.querySelectorAll('.table-tab')).find(tab =>
                    tab.textContent.includes(mappedTableId)
                );
                if (activeTab) activeTab.classList.add('active');
                elements.panelTitle.textContent = `遊戲結果 - ${mappedTableId} (全部資料)`;
            }

            // 更新總局數顯示
            updateTotalGamesCount();
            updateResultStatistics();

            refreshCurrentTable();
        }

        async function refreshCurrentTable() {
            try {
                let url;
                if (currentTableId) {
                    // 特定桌號顯示所有資料
                    url = `http://127.0.0.1:8000/api/tables/${currentTableId}?limit=1000`;
                } else {
                    // 全部桌號仍保持30筆限制
                    url = 'http://127.0.0.1:8000/api/latest?limit=30';
                }

                const response = await fetch(url);
                const data = await response.json();

                gameResults = [];
                const records = data.records || [];

                records.forEach(record => {
                    applyRecord(record);
                });

                updateGameTable();
                updateTotalGamesCount();
                updateResultStatistics();
                addEvent('system', `刷新${currentTableId || '全部'}桌號數據`, {
                    table: currentTableId || '全部',
                    count: records.length
                });

                lastActivityTime = Date.now();

            } catch (error) {
                console.error('刷新數據失敗:', error);
                addEvent('error', '刷新數據失敗', { error: error.message });
                consecutiveErrors++;
            }
        }

        function toggleOverview() {
            isOverviewMode = !isOverviewMode;
            if (isOverviewMode) {
                elements.tableOverview.classList.remove('hidden');
                elements.detailView.classList.add('hidden');
                elements.overviewToggleText.textContent = '詳細模式';
                updateOverview();
            } else {
                elements.tableOverview.classList.add('hidden');
                elements.detailView.classList.remove('hidden');
                elements.overviewToggleText.textContent = '總覽模式';
            }
        }

        function refreshTables() {
            fetchTables();
            addEvent('system', '手動刷新桌號列表', {});
        }

        function toggleConnection() {
            if (isConnected) {
                disconnect();
            } else {
                connect();
            }
        }

        function connect() {
            const url = 'http://127.0.0.1:8000/api/stream?event_types=result,error,heartbeat';
            
            connectionStartTime = Date.now();
            firstResultTime = null;

            elements.status.className = 'status-indicator connecting';
            elements.text.textContent = '連接中...';
            elements.connectBtn.textContent = '取消';

            eventSource = new EventSource(url);

            eventSource.onopen = function() {
                isConnected = true;
                elements.status.className = 'status-indicator connected';
                elements.text.textContent = '已連接';
                elements.connectBtn.textContent = '斷開';

                const connectTime = Date.now() - connectionStartTime;
                elements.connectionTime.textContent = connectTime + 'ms';

                // 重置總局數計數器和活動時間
                recordStore.clear();
                updateTotalGamesCount();
                updateActivityTime(); // 重置活動時間
                consecutiveErrors = 0; // 重置錯誤計數

                // 開始監控計時
                monitoringStartTime = Date.now();
                startMonitoringTimer();

                addEvent('system', '連接建立', { url: url, connectTime: connectTime });

                // 立即抽取歷史資料到 recordStore
                // 使用 softRefresh 確保抓取全部桌號的最新資料
                softRefresh().then(() => {
                    updateTotalGamesCount();
                    updateGameTable();
                });

                // 開始智能刷新
                scheduleNextRefresh(); // 開始智能刷新調度
                fetchTables(); // 立即獲取一次
            };

            eventSource.addEventListener('result', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleGameResult(data);
                } catch (e) {
                    console.error('解析結果數據失敗:', e);
                }
            });

            eventSource.addEventListener('error', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleError(data);
                } catch (e) {
                    console.error('解析錯誤數據失敗:', e);
                }
            });

            eventSource.addEventListener('heartbeat', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleHeartbeat(data);
                } catch (e) {
                    console.error('解析心跳數據失敗:', e);
                }
            });

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addEvent(data.event_type || 'message', '通用事件', data);
                } catch (e) {
                    console.error('解析通用事件失敗:', e);
                }
            };

            eventSource.onerror = function(event) {
                console.error('SSE 連接錯誤:', event);
                errorCount++;
                elements.errorCount.textContent = errorCount;
                
                if (!isConnected) {
                    elements.status.className = 'status-indicator';
                    elements.text.textContent = '連接失敗';
                    elements.connectBtn.textContent = '重連';
                }
                
                addEvent('error', '連接錯誤', { error: event });
            };
        }

        function disconnect() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }

            if (refreshTimeoutId) {
                clearTimeout(refreshTimeoutId);
                refreshTimeoutId = null;
            }

            isConnected = false;
            elements.status.className = 'status-indicator';
            elements.text.textContent = '已斷開';
            elements.connectBtn.textContent = '連接';

            // 停止監控計時
            stopMonitoringTimer();

            addEvent('system', '連接斷開', {});
        }

        function handleGameResult(data) {
            let accepted = 0;
            let tables = new Set();

            const take = (r) => {
                try {
                    if (applyRecord(r)) {
                        accepted++;
                        // 提取桌號資訊
                        const tableId = r.table_id || r.tableId || r.table;
                        if (tableId) tables.add(tableId);
                    }
                } catch (e) {
                    console.error('applyRecord failed:', e);
                }
            };

            // 解析 payload，逐筆採納
            if (data && data.payload) {
                if (data.payload.record) {
                    take(data.payload.record);
                } else if (Array.isArray(data.payload.results)) {
                    data.payload.results.forEach(take);
                } else {
                    // 有些服務會直接把 record 放在 payload 根上
                    take(data.payload);
                }
            }

            // 只有真的有變更，才更新統計與畫面
            if (accepted > 0) {
                updateTotalGamesCount();
                updateResultStatistics();
                lastActivityTime = Date.now();
                elements.lastUpdate.textContent = new Date().toLocaleTimeString();
                updateGameTable();
            }

            // 建立事件資訊
            const eventPayload = {
                latency: data.latency_ms || 'N/A',
                accepted: accepted
            };

            // 如果有桌號資訊，加入到 payload
            if (tables.size > 0) {
                eventPayload.tables = Array.from(tables).join(', ');
            }

            addEvent('result', '收到遊戲結果', eventPayload);

            // 刷新桌號列表（如果有新桌號）
            setTimeout(fetchTables, 1000);
        }

        function handleError(data) {
            errorCount++;
            elements.errorCount.textContent = errorCount;
            addEvent('error', '系統錯誤: ' + (data.payload?.error || '未知錯誤'), data.payload);
        }

        function handleHeartbeat(data) {
            addEvent('heartbeat', '心跳檢測', {
                timestamp: data.payload?.timestamp,
                latency: data.latency_ms || 'N/A'
            });
        }

        function addGameResultFromSSE(result) {
            // Use the new applyRecord function for deduplication
            if (applyRecord(result)) {
                lastActivityTime = Date.now();
                updateGameTable();
            }
        }

        function addGameResultFromData(result) {
            const roundId = result.round_id || result.roundId || result.id || 'N/A';
            const tableId = result.table_id || result.tableId || result.table || 'N/A';
            const startTime = result.game_start_time || result.openTime || result.start_time || 'N/A';

            // 處理遊戲結果
            let gameResult = '進行中';
            const gameResultData = result.gameResult || {};
            const status = (result.game_payment_status_name || '').trim();

            if (typeof gameResultData === 'object' && [1, 2, 3, 0].includes(gameResultData.result)) {
                const resultCode = gameResultData.result;
                if (resultCode === 1) gameResult = '閒勝';
                else if (resultCode === 2) gameResult = '和局';
                else if (resultCode === 0) gameResult = '莊勝';
                else if (resultCode === 3) gameResult = '取消/無效';
            } else if (/(派彩|已彩|結束|finished)/i.test(status)) {
                gameResult = '已派彩'; // 狀態 fallback：若沒有具體結果但狀態顯示已結束
            }

            const payload = {
                roundId,
                tableId,
                startTime,
                result: gameResult,
                resultCode: gameResultData.result || -1,
                status,
                raw: result
            };

            const idx = gameResults.findIndex(
                r => String(r.tableId) === String(tableId) && String(r.roundId) === String(roundId)
            );
            if (idx >= 0) {
                // 更新舊資料（例如把「進行中」更新成「已派彩／莊勝」）
                gameResults[idx] = {
                    roundId,
                    tableId,
                    startTime,
                    gameResult,
                    status: status || '未知',
                    timestamp: Date.now(),
                    raw: result  // Include raw data for points extraction
                };
            } else {
                // 新資料才塞到陣列最前面
                gameResults.unshift({
                    roundId,
                    tableId,
                    startTime,
                    gameResult,
                    status: status || '未知',
                    timestamp: Date.now(),
                    raw: result  // Include raw data for points extraction
                });
            }

            if (gameResults.length > 100) gameResults = gameResults.slice(0, 100);
        }

        function updateGameTable() {
            const tbody = elements.gameTableBody;
            tbody.innerHTML = '';

            if (gameResults.length === 0) {
                const row = tbody.insertRow();
                const cell = row.insertCell(0);
                cell.colSpan = 6;
                cell.style.textAlign = 'center';
                cell.style.color = '#888';
                const displayCurrentTableId = currentTableId ? mapTableId(currentTableId) : null;
                cell.textContent = displayCurrentTableId ? `${displayCurrentTableId} 桌暫無遊戲結果` : '暫無遊戲結果';
                return;
            }

            const filtered = gameResults.filter(r => !currentTableId || String(r.tableId) === String(currentTableId));

            // 依「局號」由大到小（最新在前），保證同桌內排序正確
            filtered.sort((a, b) => (Number(b.roundId) || 0) - (Number(a.roundId) || 0));

            // 根據選擇的桌號決定顯示筆數
            const limited = currentTableId ? filtered : filtered.slice(0, 30);
            const sortedResults = limited;

            sortedResults.forEach((result, index) => {
                const row = tbody.insertRow();

                // 根據狀態添加不同的樣式
                if (result.status === '投注中') {
                    row.className = 'betting';
                } else if (result.status === '開獎中' || result.gameResult === '進行中') {
                    row.className = 'in-progress';
                } else if (index === 0 && (result.gameResult === '莊勝' || result.gameResult === '閒勝' || result.gameResult === '和局')) {
                    row.className = 'fresh'; // 只有最新一筆派彩結果才顯示綠色效果
                }

                row.insertCell(0).textContent = result.roundId;
                row.insertCell(1).textContent = mapTableId(result.tableId); // 顯示映射後的桌號
                row.insertCell(2).textContent = formatTime(result.startTime);
                row.insertCell(3).textContent = result.gameResult;

                // 新增點數欄位
                const pointsCell = row.insertCell(4);
                let bankerPoints = null;
                let playerPoints = null;

                // Debug: log the data structure
                console.debug('[POINTS DEBUG]', 'result object:', result);
                console.debug('[POINTS DEBUG]', 'raw object:', result.raw);

                // 嘗試從多個位置提取點數信息
                if (result.raw) {
                    // 方法1: 直接在 raw 對象中查找 (測試數據格式)
                    if (result.raw.bankerPoints !== undefined && result.raw.playerPoints !== undefined) {
                        bankerPoints = result.raw.bankerPoints;
                        playerPoints = result.raw.playerPoints;
                    }
                    // 方法2: 在 gameResult 對象中查找 (測試數據格式)
                    else if (result.raw.gameResult && typeof result.raw.gameResult === 'object') {
                        const gr = result.raw.gameResult;
                        if (gr.bankerPoints !== undefined && gr.playerPoints !== undefined) {
                            bankerPoints = gr.bankerPoints;
                            playerPoints = gr.playerPoints;
                        }
                        // 方法3: 真實數據格式 - player_point/banker_point
                        else if (gr.player_point !== undefined && gr.banker_point !== undefined &&
                                 gr.player_point !== "" && gr.banker_point !== "" &&
                                 gr.player_point !== "-" && gr.banker_point !== "-") {
                            playerPoints = gr.player_point;
                            bankerPoints = gr.banker_point;
                        }
                        // 方法4: 真實數據格式 - maximum_points
                        else if (gr.player_maximum_points !== undefined && gr.banker_maximum_points !== undefined &&
                                 gr.player_maximum_points !== "" && gr.banker_maximum_points !== "" &&
                                 gr.player_maximum_points !== "-" && gr.banker_maximum_points !== "-") {
                            playerPoints = gr.player_maximum_points;
                            bankerPoints = gr.banker_maximum_points;
                        }
                    }
                }

                if (bankerPoints !== null && playerPoints !== null) {
                    pointsCell.innerHTML = `
                        <div class="points-display">
                            <span class="banker-points">${bankerPoints}</span>
                            <span class="points-separator">/</span>
                            <span class="player-points">${playerPoints}</span>
                        </div>
                    `;
                } else {
                    pointsCell.textContent = '等待點數';
                    pointsCell.style.color = '#888';
                    pointsCell.style.fontSize = '0.85rem';
                }

                const statusCell = row.insertCell(5);
                const statusBadge = document.createElement('span');
                statusBadge.className = 'badge ' + getStatusBadgeClass(result.status);
                statusBadge.textContent = result.status;
                statusCell.appendChild(statusBadge);
            });
        }

        function formatTime(timeStr) {
            if (!timeStr || timeStr === 'N/A') return 'N/A';
            try {
                if (typeof timeStr === 'string' && timeStr.includes(':')) {
                    return timeStr; // 已經是時間格式
                }
                const date = new Date(timeStr);
                return date.toLocaleTimeString();
            } catch (e) {
                return timeStr;
            }
        }

        function getStatusBadgeClass(status) {
            if (status === '已結束' || status === 'finished') return 'badge-success';
            if (status === '投注中') return 'badge-betting';
            if (status === '開獎中' || status === '進行中' || status === 'running') return 'badge-in-progress';
            if (status === '錯誤' || status === 'error') return 'badge-danger';
            return 'badge-warning';
        }

        function formatEventPayload(type, payload) {
            if (!payload || Object.keys(payload).length === 0) return '';

            switch (type) {
                case 'result':
                    return `
                        <div class="event-details">
                            ${payload.latency !== 'N/A' ? `<span class="detail-item">延遲: ${payload.latency}ms</span>` : ''}
                            ${payload.accepted ? `<span class="detail-item">接受: ${payload.accepted} 筆</span>` : ''}
                            ${payload.tables ? `<span class="detail-item">桌號: ${payload.tables.split(', ').map(t => mapTableId(t)).join(', ')}</span>` : ''}
                        </div>
                    `;

                case 'system':
                    let systemDetails = '';
                    if (payload.table) {
                        const displayTable = payload.table === '全部' ? '全部' : mapTableId(payload.table);
                        systemDetails += `<span class="detail-item">桌號: ${displayTable}</span>`;
                    }
                    if (payload.count) systemDetails += `<span class="detail-item">數量: ${payload.count}</span>`;
                    if (payload.url) systemDetails += `<span class="detail-item">連接: ${payload.url}</span>`;
                    if (payload.connectTime) systemDetails += `<span class="detail-item">耗時: ${payload.connectTime}ms</span>`;
                    return systemDetails ? `<div class="event-details">${systemDetails}</div>` : '';

                case 'heartbeat':
                    let heartbeatDetails = '';
                    if (payload.timestamp) {
                        try {
                            const time = new Date(payload.timestamp * 1000).toLocaleTimeString();
                            heartbeatDetails += `<span class="detail-item">時間: ${time}</span>`;
                        } catch (e) {
                            heartbeatDetails += `<span class="detail-item">時間: ${payload.timestamp}</span>`;
                        }
                    }
                    if (payload.latency && payload.latency !== 'N/A') {
                        heartbeatDetails += `<span class="detail-item">延遲: ${payload.latency}ms</span>`;
                    }
                    return heartbeatDetails ? `<div class="event-details">${heartbeatDetails}</div>` : '';

                case 'error':
                    return `
                        <div class="event-details error-details">
                            ${payload.error ? `<span class="detail-item">錯誤: ${payload.error}</span>` : ''}
                        </div>
                    `;

                default:
                    // 對於其他類型，簡化顯示重要字段
                    const importantFields = ['status', 'count', 'message', 'success'];
                    let defaultDetails = '';
                    for (const field of importantFields) {
                        if (payload[field] !== undefined) {
                            defaultDetails += `<span class="detail-item">${field}: ${payload[field]}</span>`;
                        }
                    }
                    return defaultDetails ? `<div class="event-details">${defaultDetails}</div>` : '';
            }
        }

        function addEvent(type, title, payload) {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item ' + type;

            const now = new Date();
            const timeStr = now.toLocaleTimeString();

            eventItem.innerHTML = `
                <div class="event-header">
                    <span class="event-type">${type}</span>
                    <span class="event-time">${timeStr}</span>
                </div>
                <div class="event-content">
                    <strong>${title}</strong>
                    ${formatEventPayload(type, payload)}
                </div>
            `;

            elements.eventsList.insertBefore(eventItem, elements.eventsList.firstChild);

            // 只保留最新 20 個事件
            while (elements.eventsList.children.length > 20) {
                elements.eventsList.removeChild(elements.eventsList.lastChild);
            }
        }

        // 確認清空結果
        function confirmClearResults() {
            if (confirm('🗑️ 確定要清空所有結果嗎？\n\n此操作將會：\n• 清除所有遊戲結果\n• 清空事件日誌\n\n此操作無法復原！')) {
                clearResults();
                addEvent('system', '用戶手動清空結果', {
                    timestamp: new Date().toLocaleString(),
                    action: 'clear_results'
                });
            }
        }

        function clearResults() {
            gameResults = [];
            updateGameTable();
            elements.eventsList.innerHTML = '<div style="text-align: center; color: #888;">事件已清空</div>';
        }

        // 確認重置統計
        function confirmResetStats() {
            if (confirm('📊 確定要重置所有統計嗎？\n\n此操作將會：\n• 重置錯誤計數\n• 清空所有遊戲結果\n• 重置監控時間\n• 清空事件記錄\n\n此操作無法復原！')) {
                resetStats();
                addEvent('system', '用戶手動重置統計', {
                    timestamp: new Date().toLocaleString(),
                    action: 'reset_stats'
                });
            }
        }

        function resetStats() {
            errorCount = 0;
            resultTimes = [];
            firstResultTime = null;
            gameResults = [];
            recordStore.clear();

            updateTotalGamesCount();
            updateResultStatistics();
            elements.errorCount.textContent = '0';
            elements.lastUpdate.textContent = '--';

            // 重置監控時間
            resetMonitoringTimer();

            updateGameTable();
            clearResults();
        }

        // 格式化時間長度
        function formatDuration(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) {
                return `${days}天 ${hours % 24}時 ${minutes % 60}分`;
            } else if (hours > 0) {
                return `${hours}時 ${minutes % 60}分 ${seconds % 60}秒`;
            } else if (minutes > 0) {
                return `${minutes}分 ${seconds % 60}秒`;
            } else {
                return `${seconds}秒`;
            }
        }

        // 更新監控時長
        function updateMonitoringDuration() {
            if (monitoringStartTime === null) {
                elements.monitoringDuration.textContent = '--';
                return;
            }
            const duration = Date.now() - monitoringStartTime;
            elements.monitoringDuration.textContent = formatDuration(duration);
        }

        // 啟動監控時長定時器
        function startMonitoringTimer() {
            if (monitoringDurationInterval) {
                clearInterval(monitoringDurationInterval);
            }
            monitoringDurationInterval = setInterval(updateMonitoringDuration, 1000);
            updateMonitoringDuration(); // 立即更新一次
        }

        // 重置監控時間（只在連接時使用）
        function resetMonitoringTimer() {
            if (isConnected) {
                monitoringStartTime = Date.now();
            } else {
                monitoringStartTime = null;
            }
            updateMonitoringDuration();
        }

        // 停止監控計時器
        function stopMonitoringTimer() {
            if (monitoringDurationInterval) {
                clearInterval(monitoringDurationInterval);
                monitoringDurationInterval = null;
            }
            monitoringStartTime = null;
            updateMonitoringDuration();
        }

        // 初始化監控時長顯示（等待連接）
        updateMonitoringDuration();

        // ===== 資料導出功能 =====

        // 導出相關變量
        let exportPreviewTimer = null;
        const INGEST_KEY = 'baccaratt9webapi'; // 從環境獲取或配置

        // 打開導出模態框
        function openExportModal() {
            const modal = document.getElementById('exportModal');
            modal.classList.remove('hidden');

            // 初始化導出選項
            initializeExportOptions();

            // 更新預覽
            updateExportPreview();

            // 添加事件監聽器
            addExportEventListeners();

            addEvent('system', '打開導出面板', {});
        }

        // 關閉導出模態框
        function closeExportModal() {
            const modal = document.getElementById('exportModal');
            modal.classList.add('hidden');

            // 清理定時器
            if (exportPreviewTimer) {
                clearTimeout(exportPreviewTimer);
                exportPreviewTimer = null;
            }

            // 重置按鈕狀態
            resetExportButton();
        }

        // 初始化導出選項
        function initializeExportOptions() {
            // 設置默認日期（今天）
            const today = new Date();
            const todayString = today.toISOString().split('T')[0];
            document.getElementById('exportEndDate').value = todayString;

            // 設置默認開始日期（一週前）
            const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            const weekAgoString = weekAgo.toISOString().split('T')[0];
            document.getElementById('exportStartDate').value = weekAgoString;

            // 填充桌號選項
            const tableSelect = document.getElementById('exportTableId');
            tableSelect.innerHTML = '<option value="">全部桌號</option>';

            // 使用現有的 availableTables 數據
            availableTables.forEach(table => {
                const option = document.createElement('option');
                option.value = table.table_id;
                const displayTableId = mapTableId(table.table_id);
                option.textContent = `${displayTableId} (${table.total_games} 局)`;
                tableSelect.appendChild(option);
            });

            // 如果當前有選擇桌號，設為默認
            if (currentTableId) {
                tableSelect.value = currentTableId;
            }
        }

        // 添加事件監聽器
        function addExportEventListeners() {
            // 監聽所有篩選條件變更
            const filterInputs = [
                'exportTableId', 'exportStartDate', 'exportEndDate',
                'exportStatus', 'exportLimit'
            ];

            filterInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('change', debounceUpdatePreview);
                }
            });

            // 監聽格式選擇變更
            const formatRadios = document.querySelectorAll('input[name="exportFormat"]');
            formatRadios.forEach(radio => {
                radio.addEventListener('change', updateExportPreview);
            });
        }

        // 防抖更新預覽
        function debounceUpdatePreview() {
            if (exportPreviewTimer) {
                clearTimeout(exportPreviewTimer);
            }
            exportPreviewTimer = setTimeout(updateExportPreview, 300);
        }

        // 更新導出預覽
        async function updateExportPreview() {
            try {
                const filters = getExportFilters();
                const format = getSelectedFormat();

                // 構建預覽請求URL（只獲取計數，不實際導出）
                const params = new URLSearchParams();
                if (filters.table_id) params.set('table_id', filters.table_id);
                if (filters.start_date) params.set('start_date', filters.start_date);
                if (filters.end_date) params.set('end_date', filters.end_date);
                if (filters.status_filter) params.set('status_filter', filters.status_filter);
                if (filters.limit) params.set('limit', filters.limit);

                // 使用現有的API獲取記錄數量預估
                let apiUrl;
                if (filters.table_id) {
                    apiUrl = `http://127.0.0.1:8000/api/tables/${filters.table_id}?limit=1`;
                } else {
                    apiUrl = 'http://127.0.0.1:8000/api/latest?limit=1';
                }

                const response = await fetch(apiUrl);
                if (response.ok) {
                    const data = await response.json();
                    let estimatedCount = data.total || 0;

                    // 如果有限制條件，調整預估
                    if (filters.limit && filters.limit < estimatedCount) {
                        estimatedCount = filters.limit;
                    }

                    // 更新預覽顯示
                    updatePreviewDisplay(estimatedCount, filters, format);
                } else {
                    updatePreviewDisplay(0, filters, format);
                }

            } catch (error) {
                console.error('更新導出預覽失敗:', error);
                updatePreviewDisplay(0, {}, getSelectedFormat());
            }
        }

        // 更新預覽顯示
        function updatePreviewDisplay(count, filters, format) {
            // 更新記錄數量
            document.getElementById('exportPreviewCount').textContent = `${count.toLocaleString()} 筆記錄`;

            // 更新桌號範圍
            let tableRange = '全部桌號';
            if (filters.table_id) {
                tableRange = mapTableId(filters.table_id);
            } else if (availableTables.length > 0) {
                const tableNames = availableTables.map(t => mapTableId(t.table_id)).sort();
                if (tableNames.length <= 3) {
                    tableRange = tableNames.join(', ');
                } else {
                    tableRange = `${tableNames[0]} ~ ${tableNames[tableNames.length - 1]} 等 ${tableNames.length} 桌`;
                }
            }
            document.getElementById('exportPreviewTables').textContent = tableRange;

            // 估算檔案大小（粗略估算）
            let sizeEstimate = '計算中...';
            if (count > 0) {
                const bytesPerRecord = format === 'json' ? 800 : format === 'excel' ? 200 : 150;
                const totalBytes = count * bytesPerRecord;

                if (totalBytes < 1024) {
                    sizeEstimate = `${totalBytes} B`;
                } else if (totalBytes < 1024 * 1024) {
                    sizeEstimate = `${(totalBytes / 1024).toFixed(1)} KB`;
                } else {
                    sizeEstimate = `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;
                }
            } else {
                sizeEstimate = '0 B';
            }
            document.getElementById('exportPreviewSize').textContent = sizeEstimate;
        }

        // 獲取導出篩選條件
        function getExportFilters() {
            return {
                table_id: document.getElementById('exportTableId').value || null,
                start_date: document.getElementById('exportStartDate').value || null,
                end_date: document.getElementById('exportEndDate').value || null,
                status_filter: document.getElementById('exportStatus').value || null,
                limit: document.getElementById('exportLimit').value ? parseInt(document.getElementById('exportLimit').value) : null
            };
        }

        // 獲取選擇的格式
        function getSelectedFormat() {
            const formatRadio = document.querySelector('input[name="exportFormat"]:checked');
            return formatRadio ? formatRadio.value : 'json';
        }

        // 開始導出
        async function startExport() {
            const exportButton = document.getElementById('exportButton');
            const exportButtonText = document.getElementById('exportButtonText');
            const exportButtonSpinner = document.getElementById('exportButtonSpinner');

            try {
                // 更新按鈕狀態
                exportButton.disabled = true;
                exportButtonText.textContent = '導出中...';
                exportButtonSpinner.classList.remove('hidden');

                const filters = getExportFilters();
                const format = getSelectedFormat();

                addEvent('system', '開始導出資料', {
                    format: format.toUpperCase(),
                    table: filters.table_id ? mapTableId(filters.table_id) : '全部',
                    limit: filters.limit || '無限制'
                });

                // 構建API請求URL
                const params = new URLSearchParams();
                if (filters.table_id) params.set('table_id', filters.table_id);
                if (filters.start_date) params.set('start_date', filters.start_date);
                if (filters.end_date) params.set('end_date', filters.end_date);
                if (filters.status_filter) params.set('status_filter', filters.status_filter);
                if (filters.limit) params.set('limit', filters.limit.toString());

                const apiUrl = `http://127.0.0.1:8000/api/export/${format}?${params.toString()}`;

                // 發送導出請求
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'x-ingest-key': INGEST_KEY
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text().catch(() => '未知錯誤');
                    throw new Error(`導出失敗: ${response.status} ${response.statusText} - ${errorText}`);
                }

                // 獲取檔案名稱
                const contentDisposition = response.headers.get('content-disposition');
                let filename = `t9_export_${format}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${format}`;
                if (contentDisposition && contentDisposition.includes('filename=')) {
                    filename = contentDisposition.split('filename=')[1].replace(/"/g, '');
                }

                // 下載檔案
                const blob = await response.blob();
                const downloadUrl = window.URL.createObjectURL(blob);
                const downloadLink = document.createElement('a');
                downloadLink.href = downloadUrl;
                downloadLink.download = filename;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                window.URL.revokeObjectURL(downloadUrl);

                // 獲取導出統計
                const totalRecords = response.headers.get('X-Total-Records') || '未知';
                const fileSize = (blob.size / 1024).toFixed(1);

                addEvent('system', '導出完成', {
                    format: format.toUpperCase(),
                    filename: filename,
                    records: totalRecords,
                    size: `${fileSize} KB`
                });

                // 重置按鈕狀態並關閉模態框
                resetExportButton();
                setTimeout(() => {
                    closeExportModal();
                }, 500); // 延遲500ms讓用戶看到成功狀態

            } catch (error) {
                console.error('導出錯誤:', error);
                addEvent('error', '導出失敗', { error: error.message });

                // 確保重置按鈕狀態
                resetExportButton();
            } finally {
                // 無論成功或失敗都確保重置按鈕狀態
                setTimeout(() => {
                    resetExportButton();
                }, 100);
            }
        }

        // 重置導出按鈕狀態
        function resetExportButton() {
            const exportButton = document.getElementById('exportButton');
            const exportButtonText = document.getElementById('exportButtonText');
            const exportButtonSpinner = document.getElementById('exportButtonSpinner');

            exportButton.disabled = false;
            exportButtonText.textContent = '開始導出';
            exportButtonSpinner.classList.add('hidden');
        }

        // 模態框點擊外部關閉
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('exportModal');
            if (event.target === modal) {
                closeExportModal();
            }
        });

        // ESC鍵關閉模態框
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('exportModal');
                if (!modal.classList.contains('hidden')) {
                    closeExportModal();
                }
            }
        });

        // 自動連接
        setTimeout(() => {
            if (!isConnected) {
                connect();
            }
        }, 1000);
    </script>
</body>
</html>