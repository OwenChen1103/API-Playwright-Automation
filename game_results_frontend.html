<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T9 éŠæˆ²çµæœå³æ™‚ç›£æ§ - åˆ†æ¡Œé¡¯ç¤º</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #1a1a1a; color: #fff; }
        .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .title { font-size: 2.5rem; font-weight: 600; margin-bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: #888; font-size: 1.1rem; }
        
        .connection-status { display: flex; align-items: center; gap: 8px; margin-bottom: 20px; }
        .status-indicator { width: 12px; height: 12px; border-radius: 50%; background: #ef4444; }
        .status-indicator.connected { background: #4ade80; }
        .status-indicator.connecting { background: #fbbf24; animation: pulse 1s infinite; }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        
        .btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s; }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5a6fd8; }
        .btn-secondary { background: #6b7280; color: white; }
        .btn-secondary:hover { background: #5f656d; }
        .btn-small { padding: 4px 8px; font-size: 0.8rem; }
        
        .controls { display: flex; align-items: center; gap: 15px; margin-bottom: 20px; }
        .table-selector { display: flex; align-items: center; gap: 10px; }
        .table-selector select { 
            padding: 8px 12px; 
            border: 1px solid #444; 
            border-radius: 6px; 
            background: #2a2a2a; 
            color: #fff; 
            min-width: 200px;
        }
        .table-tabs { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 20px; }
        .table-tab { 
            padding: 8px 16px; 
            border: 1px solid #444; 
            border-radius: 6px; 
            background: #2a2a2a; 
            color: #fff; 
            cursor: pointer; 
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        .table-tab:hover { background: #3a3a3a; }
        .table-tab.active { background: #667eea; border-color: #667eea; }
        .table-tab.has-activity { border-left: 4px solid #4ade80; }
        
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 30px; }
        .stat-card { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; padding: 15px; }
        .stat-title { font-size: 0.9rem; color: #888; margin-bottom: 5px; }
        .stat-value { font-size: 1.5rem; font-weight: 600; }
        .stat-value.success { color: #4ade80; }
        .stat-value.warning { color: #fbbf24; }
        .stat-value.error { color: #ef4444; }
        .stat-value.info { color: #60a5fa; }
        .stat-value.banker { color: #ef4444; }
        .stat-value.player { color: #3b82f6; }
        .stat-value.tie { color: #22c55e; }

        .result-statistics { margin-top: 20px; border-top: 1px solid #333; padding-top: 20px; }
        .result-stats { font-size: 0.9rem; color: #bbb; }
        .verify-ok { color: #4ade80; }
        .verify-error { color: #f87171; font-weight: bold; }
        
        .main-content { display: grid; grid-template-columns: 1fr 400px; gap: 20px; height: 70vh; }
        .panel { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; overflow: hidden; }
        .panel-header { background: #333; padding: 15px; font-weight: 600; border-bottom: 1px solid #444; display: flex; justify-content: space-between; align-items: center; }
        .panel-content { height: calc(100% - 60px); overflow-y: auto; padding: 15px; }
        
        .game-table { width: 100%; }
        .game-table th, .game-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #333; }
        .game-table th { background: #333; color: #aaa; font-size: 0.9rem; }
        .game-table tr:nth-child(even) { background: #1a1a1a; }
        .game-table tr.fresh { background: #0d4f3c; animation: fadeIn 0.5s ease-in; }
        .game-table tr.in-progress { background: #1a2e3a; }
        .game-table tr.betting { background: #3a2a1a; }
        
        @keyframes fadeIn { from { opacity: 0; background: #1a472a; } to { opacity: 1; background: #0d4f3c; } }
        
        .event-item { margin-bottom: 10px; padding: 12px; background: #1a1a1a; border: 1px solid #333; border-radius: 6px; border-left: 4px solid #667eea; }
        .event-item.result { border-left-color: #4ade80; }
        .event-item.error { border-left-color: #ef4444; }
        .event-item.heartbeat { border-left-color: #fbbf24; }
        
        .event-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .event-type { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; background: #333; }
        .event-time { font-size: 0.8rem; color: #888; }
        .event-content { font-size: 0.9rem; }
        .event-content pre { background: #111; padding: 8px; border-radius: 4px; overflow-x: auto; font-size: 0.8rem; }

        .event-details { margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px; }
        .detail-item {
            display: inline-block;
            background: rgba(102, 126, 234, 0.1);
            color: #a3a3f5;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        .error-details .detail-item {
            background: rgba(239, 68, 68, 0.1);
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.2);
        }
        
        .badge { padding: 2px 6px; border-radius: 3px; font-size: 0.8rem; }
        .badge-success { background: #166534; color: #86efac; }
        .badge-danger { background: #7f1d1d; color: #fca5a5; }
        .badge-warning { background: #92400e; color: #fbbf24; }
        .badge-info { background: #1e3a8a; color: #93c5fd; }
        .badge-betting { background: #92400e; color: #fed7aa; }
        .badge-in-progress { background: #065f46; color: #6ee7b7; }
        
        .table-overview { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px; }
        .table-card { background: #2a2a2a; border: 1px solid #333; border-radius: 8px; padding: 15px; cursor: pointer; transition: all 0.2s; }
        .table-card:hover { background: #3a3a3a; transform: translateY(-2px); }
        .table-card.active { border-color: #667eea; background: #2a2e3a; }
        .table-card-header { display: flex; justify-content: between; align-items: center; margin-bottom: 10px; }
        .table-card-title { font-size: 1.1rem; font-weight: 600; color: #667eea; }
        .table-card-status { font-size: 0.8rem; padding: 2px 6px; border-radius: 4px; }
        .table-card-content { font-size: 0.9rem; }
        .table-card-item { margin-bottom: 5px; }
        
        .hidden { display: none; }

        .points-display {
            display: flex;
            align-items: center;
            gap: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .banker-points {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        .player-points {
            color: #60a5fa;
            background: rgba(96, 165, 250, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid rgba(96, 165, 250, 0.3);
        }
        .points-separator {
            color: #666;
            font-weight: normal;
        }

        /* ===== å°å‡ºæ¨¡æ…‹æ¡†æ¨£å¼ ===== */
        .export-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }

        .export-modal.hidden {
            display: none;
        }

        .export-modal-content {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            animation: modalSlideIn 0.3s ease-out;
        }

        @keyframes modalSlideIn {
            from { opacity: 0; transform: scale(0.9) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }

        .export-modal-header {
            background: #333;
            padding: 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 12px 12px 0 0;
        }

        .export-modal-header h2 {
            margin: 0;
            color: #667eea;
            font-size: 1.4rem;
        }

        .export-modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .export-modal-close:hover {
            background: rgba(239, 68, 68, 0.1);
            color: #ef4444;
        }

        .export-modal-body {
            padding: 20px;
        }

        .export-section {
            margin-bottom: 25px;
        }

        .export-section h3 {
            margin: 0 0 15px 0;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 600;
        }

        /* æ ¼å¼é¸æ“‡æ¨£å¼ */
        .format-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .format-option {
            cursor: pointer;
        }

        .format-option input[type="radio"] {
            display: none;
        }

        .format-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 15px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            transition: all 0.2s;
        }

        .format-option input[type="radio"]:checked + .format-card {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .format-card:hover {
            border-color: #555;
            background: #252525;
        }

        .format-option input[type="radio"]:checked + .format-card:hover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.15);
        }

        .format-icon {
            font-size: 24px;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
        }

        .format-info {
            flex: 1;
        }

        .format-title {
            font-weight: 600;
            color: #fff;
            margin-bottom: 4px;
        }

        .format-desc {
            font-size: 0.85rem;
            color: #888;
        }

        /* ç¯©é¸æ¢ä»¶æ¨£å¼ */
        .filter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .filter-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .filter-item label {
            font-size: 0.9rem;
            color: #ccc;
            font-weight: 500;
        }

        .filter-item select,
        .filter-item input {
            padding: 10px 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 0.9rem;
            transition: border-color 0.2s;
        }

        .filter-item select:focus,
        .filter-item input:focus {
            outline: none;
            border-color: #667eea;
        }

        /* é è¦½è³‡è¨Šæ¨£å¼ */
        .export-preview {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
        }

        .preview-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .preview-item:last-child {
            margin-bottom: 0;
        }

        .preview-label {
            font-size: 0.9rem;
            color: #888;
            flex: 1;
        }

        .preview-value {
            font-weight: 600;
            color: #4ade80;
            font-size: 0.9rem;
        }

        /* æ¨¡æ…‹æ¡†åº•éƒ¨ */
        .export-modal-footer {
            background: #333;
            padding: 20px;
            border-top: 1px solid #444;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            border-radius: 0 0 12px 12px;
        }

        .export-modal-footer .btn {
            min-width: 100px;
        }

        /* è¼‰å…¥å‹•ç•« */
        .spinner {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1 class="title">T9 éŠæˆ²çµæœå³æ™‚ç›£æ§</h1>
        </header>

        <div class="connection-status">
            <div class="status-indicator" id="connectionStatus"></div>
            <span id="connectionText">æœªé€£æ¥</span>
            <button class="btn btn-primary" id="connectBtn" onclick="toggleConnection()">é€£æ¥</button>
            <button class="btn btn-secondary" onclick="confirmClearResults()">æ¸…ç©ºçµæœ</button>
            <button class="btn btn-secondary" onclick="confirmResetStats()">é‡ç½®çµ±è¨ˆ</button>
            <button class="btn btn-secondary" onclick="refreshTables()">åˆ·æ–°æ¡Œè™Ÿ</button>
        </div>

        <div class="controls">
            <div class="table-selector">
                <label for="tableSelect">é¸æ“‡æ¡Œè™Ÿ:</label>
                <select id="tableSelect" onchange="switchTable()">
                    <option value="">è¼‰å…¥ä¸­...</option>
                </select>
            </div>
            <button class="btn btn-secondary btn-small" onclick="toggleOverview()">
                <span id="overviewToggleText">ç¸½è¦½æ¨¡å¼</span>
            </button>
            <button class="btn btn-primary btn-small" onclick="openExportModal()" title="å°å‡ºè³‡æ–™">
                ğŸ“Š å°å‡ºè³‡æ–™
            </button>
        </div>

        <!-- æ¡Œè™Ÿæ¨™ç±¤ -->
        <div class="table-tabs" id="tableTabs"></div>

        <!-- ç¸½è¦½æ¨¡å¼ -->
        <div class="table-overview hidden" id="tableOverview"></div>

        <div class="stats">
            <div class="stat-card">
                <div class="stat-title">é€£æ¥æ™‚é–“</div>
                <div class="stat-value" id="connectionTime">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">ç›£æ§æ™‚é•·</div>
                <div class="stat-value info" id="monitoringDuration">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">ç•¶å‰æ¡Œè™Ÿ</div>
                <div class="stat-value info" id="currentTable">å…¨éƒ¨</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">ç¸½å±€æ•¸</div>
                <div class="stat-value success" id="totalResults">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">æ´»èºæ¡Œæ•¸</div>
                <div class="stat-value" id="activeTables">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">æœ€å¾Œæ›´æ–°</div>
                <div class="stat-value" id="lastUpdate">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">éŒ¯èª¤æ•¸</div>
                <div class="stat-value error" id="errorCount">0</div>
            </div>
        </div>

        <!-- èŠé–’å’Œçµ±è¨ˆå€åŸŸ -->
        <div class="stats result-statistics" id="resultStatistics">
            <div class="stat-card">
                <div class="stat-title">èŠå‹</div>
                <div class="stat-value banker" id="bankerWins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">é–’å‹</div>
                <div class="stat-value player" id="playerWins">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">å’Œå±€</div>
                <div class="stat-value tie" id="tieResults">0</div>
            </div>
        </div>

        <div class="main-content" id="detailView">
            <div class="panel">
                <div class="panel-header">
                    <span id="panelTitle">éŠæˆ²çµæœ (æœ€æ–° 30 ç­†)</span>
                    <button class="btn btn-secondary btn-small" onclick="refreshCurrentTable()">åˆ·æ–°</button>
                </div>
                <div class="panel-content">
                    <table class="game-table" id="gameTable">
                        <thead>
                            <tr>
                                <th>å±€è™Ÿ</th>
                                <th>æ¡Œè™Ÿ</th>
                                <th>é–‹å±€æ™‚é–“</th>
                                <th>çµæœ</th>
                                <th>é»æ•¸ (èŠ/é–’)</th>
                                <th>ç‹€æ…‹</th>
                            </tr>
                        </thead>
                        <tbody id="gameTableBody">
                            <tr>
                                <td colspan="6" style="text-align: center; color: #888;">ç­‰å¾…é€£æ¥...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="panel">
                <div class="panel-header">ç³»çµ±äº‹ä»¶</div>
                <div class="panel-content" id="eventsList">
                    <div style="text-align: center; color: #888;">ç­‰å¾…äº‹ä»¶...</div>
                </div>
            </div>
        </div>

        <!-- å°å‡ºè³‡æ–™æ¨¡æ…‹æ¡† -->
        <div id="exportModal" class="export-modal hidden">
            <div class="export-modal-content">
                <div class="export-modal-header">
                    <h2>ğŸ“Š å°å‡ºè³‡æ–™</h2>
                    <button class="export-modal-close" onclick="closeExportModal()">&times;</button>
                </div>

                <div class="export-modal-body">
                    <!-- å°å‡ºæ ¼å¼é¸æ“‡ -->
                    <div class="export-section">
                        <h3>1. é¸æ“‡æ ¼å¼</h3>
                        <div class="format-options">
                            <label class="format-option">
                                <input type="radio" name="exportFormat" value="json" checked>
                                <div class="format-card">
                                    <div class="format-icon">ğŸ“„</div>
                                    <div class="format-info">
                                        <div class="format-title">JSON</div>
                                        <div class="format-desc">çµæ§‹åŒ–è³‡æ–™ï¼Œé©åˆç¨‹å¼è™•ç†</div>
                                    </div>
                                </div>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="exportFormat" value="csv">
                                <div class="format-card">
                                    <div class="format-icon">ğŸ“ˆ</div>
                                    <div class="format-info">
                                        <div class="format-title">CSV</div>
                                        <div class="format-desc">Excel å¯é–‹å•Ÿï¼Œé©åˆåˆ†æ</div>
                                    </div>
                                </div>
                            </label>
                            <label class="format-option">
                                <input type="radio" name="exportFormat" value="excel">
                                <div class="format-card">
                                    <div class="format-icon">ğŸ“Š</div>
                                    <div class="format-info">
                                        <div class="format-title">Excel</div>
                                        <div class="format-desc">å¤šå·¥ä½œè¡¨ï¼ŒåŠŸèƒ½å®Œæ•´</div>
                                    </div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- ç¯©é¸æ¢ä»¶ -->
                    <div class="export-section">
                        <h3>2. ç¯©é¸æ¢ä»¶</h3>
                        <div class="filter-grid">
                            <div class="filter-item">
                                <label for="exportTableId">æ¡Œè™Ÿ:</label>
                                <select id="exportTableId">
                                    <option value="">å…¨éƒ¨æ¡Œè™Ÿ</option>
                                </select>
                            </div>
                            <div class="filter-item">
                                <label for="exportStartDate">é–‹å§‹æ—¥æœŸ:</label>
                                <input type="date" id="exportStartDate">
                            </div>
                            <div class="filter-item">
                                <label for="exportEndDate">çµæŸæ—¥æœŸ:</label>
                                <input type="date" id="exportEndDate">
                            </div>
                            <div class="filter-item">
                                <label for="exportStatus">ç‹€æ…‹ç¯©é¸:</label>
                                <select id="exportStatus">
                                    <option value="">å…¨éƒ¨ç‹€æ…‹</option>
                                    <option value="æŠ•æ³¨ä¸­">æŠ•æ³¨ä¸­</option>
                                    <option value="é–‹çä¸­">é–‹çä¸­</option>
                                    <option value="å·²çµæŸ">å·²çµæŸ</option>
                                    <option value="å·²æ´¾å½©">å·²æ´¾å½©</option>
                                </select>
                            </div>
                            <div class="filter-item">
                                <label for="exportLimit">ç­†æ•¸é™åˆ¶:</label>
                                <select id="exportLimit">
                                    <option value="">ä¸é™åˆ¶</option>
                                    <option value="100">100 ç­†</option>
                                    <option value="500">500 ç­†</option>
                                    <option value="1000">1000 ç­†</option>
                                    <option value="5000">5000 ç­†</option>
                                    <option value="10000">10000 ç­†</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- é è¦½è³‡è¨Š -->
                    <div class="export-section">
                        <h3>3. é è¦½è³‡è¨Š</h3>
                        <div class="export-preview">
                            <div class="preview-item">
                                <span class="preview-label">å°‡å°å‡º:</span>
                                <span class="preview-value" id="exportPreviewCount">è¨ˆç®—ä¸­...</span>
                            </div>
                            <div class="preview-item">
                                <span class="preview-label">æ¡Œè™Ÿç¯„åœ:</span>
                                <span class="preview-value" id="exportPreviewTables">--</span>
                            </div>
                            <div class="preview-item">
                                <span class="preview-label">æª”æ¡ˆå¤§å°é ä¼°:</span>
                                <span class="preview-value" id="exportPreviewSize">--</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="export-modal-footer">
                    <button class="btn btn-secondary" onclick="closeExportModal()">å–æ¶ˆ</button>
                    <button class="btn btn-primary" onclick="startExport()" id="exportButton">
                        <span id="exportButtonText">é–‹å§‹å°å‡º</span>
                        <span id="exportButtonSpinner" class="spinner hidden">âŸ³</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ¡Œè™Ÿæ˜ å°„è¡¨ - å¯è¼•é¬†æ“´å±•
        const TABLE_MAPPING = {
            'WG7': 'BG_131',
            'WG8': 'BG_132',
            'WG9': 'BG_133',
            'WG10': 'BG_135',
            'WG11': 'BG_136',
            'WG12': 'BG_137',
            'WG13': 'BG_138'
            // æœªä¾†å¯ä»¥åœ¨æ­¤æ·»åŠ æ›´å¤šæ˜ å°„
        };

        // æ¡Œè™Ÿæ˜ å°„å‡½æ•¸
        function mapTableId(originalTableId) {
            if (!originalTableId) return originalTableId;
            return TABLE_MAPPING[originalTableId] || originalTableId;
        }

        // åå‘æ˜ å°„å‡½æ•¸ï¼ˆç”¨æ–¼APIèª¿ç”¨æ™‚éœ€è¦åŸå§‹æ¡Œè™Ÿï¼‰
        function unmapTableId(displayTableId) {
            if (!displayTableId) return displayTableId;
            for (const [original, display] of Object.entries(TABLE_MAPPING)) {
                if (display === displayTableId) return original;
            }
            return displayTableId;
        }

        let eventSource = null;
        let isConnected = false;
        let connectionStartTime = null;
        let firstResultTime = null;
        let errorCount = 0;
        let gameResults = [];
        let resultTimes = [];
        let availableTables = [];
        let currentTableId = '';
        let isOverviewMode = false;
        let refreshInterval = null;
        let refreshTimeoutId = null;
        let consecutiveErrors = 0;
        let isPageStuck = false;
        let lastActivityTime = Date.now();

        // ç›£æ§é–‹å§‹æ™‚é–“ï¼ˆé€£æ¥æˆåŠŸå¾Œæ‰é–‹å§‹è¨ˆæ™‚ï¼‰
        let monitoringStartTime = null;
        let monitoringDurationInterval = null;

        // æ›´æ–°æ´»å‹•æ™‚é–“çš„é€šç”¨å‡½æ•¸
        function updateActivityTime() {
            lastActivityTime = Date.now();
        }

        // ç›£è½ç”¨æˆ¶äº¤äº’äº‹ä»¶ä»¥æ›´æ–°æ´»å‹•æ™‚é–“
        document.addEventListener('click', updateActivityTime);
        document.addEventListener('keydown', updateActivityTime);
        document.addEventListener('scroll', updateActivityTime);
        document.addEventListener('mousemove', updateActivityTime);

        // Frontend store and deduplication
        const recordStore = new Map(); // key: tableId:roundId, value: { phase, hash, record }

        // Update total games count based on availableTables data
        function updateTotalGamesCount() {
            let totalGames = 0;

            if (currentTableId) {
                // è¨ˆç®—ç‰¹å®šæ¡Œè™Ÿçš„å±€æ•¸
                const targetTable = availableTables.find(table =>
                    String(table.table_id) === String(currentTableId)
                );
                totalGames = targetTable ? (targetTable.total_games || 0) : 0;
            } else {
                // è¨ˆç®—å…¨éƒ¨æ¡Œè™Ÿçš„å±€æ•¸ - ç›´æ¥åŠ ç¸½å„æ¡Œçš„ total_games
                totalGames = availableTables.reduce((sum, table) => {
                    return sum + (table.total_games || 0);
                }, 0);
            }

            elements.totalResults.textContent = totalGames;
        }

        function updateResultStatistics() {
            let totalStats = {
                banker_wins: 0,
                player_wins: 0,
                ties: 0,
                other: 0
            };

            if (currentTableId) {
                // ç‰¹å®šæ¡Œè™Ÿï¼šä½¿ç”¨å‰ç«¯ gameResults çš„å®Œæ•´è³‡æ–™ï¼ˆå› ç‚ºå·²ç¶“éæ¿¾ä¸”ç²å–äº†è©²æ¡Œæ‰€æœ‰æ­·å²ï¼‰
                const resultsToAnalyze = gameResults.filter(r => String(r.tableId) === String(currentTableId));

                resultsToAnalyze.forEach(result => {
                    const gameResult = result.gameResult;
                    if (gameResult === 'èŠå‹') {
                        totalStats.banker_wins++;
                    } else if (gameResult === 'é–’å‹') {
                        totalStats.player_wins++;
                    } else if (gameResult === 'å’Œå±€') {
                        totalStats.ties++;
                    } else if (gameResult && gameResult !== 'é€²è¡Œä¸­' && gameResult !== 'æŠ•æ³¨ä¸­' && gameResult !== 'é–‹çä¸­') {
                        totalStats.other++;
                    }
                });

                console.log('[STATS] ç‰¹å®šæ¡Œè™Ÿ', currentTableId, 'å‰ç«¯è³‡æ–™çµ±è¨ˆ:', totalStats, 'ç¸½ç­†æ•¸:', resultsToAnalyze.length);
            } else {
                // å…¨éƒ¨æ¡Œè™Ÿï¼šä½¿ç”¨å¾Œç«¯çš„å®Œæ•´çµ±è¨ˆæ•¸æ“š
                console.log('[STATS DEBUG] availableTables:', availableTables);
                console.log('[STATS DEBUG] availableTables.length:', availableTables.length);

                availableTables.forEach((table, index) => {
                    console.log(`[STATS DEBUG ${index}] Table:`, table.table_id, 'has result_statistics:', !!table.result_statistics);

                    if (table.result_statistics) {
                        console.log(`[STATS DEBUG ${index}] Stats:`, table.result_statistics);
                        totalStats.banker_wins += table.result_statistics.banker_wins || 0;
                        totalStats.player_wins += table.result_statistics.player_wins || 0;
                        totalStats.ties += table.result_statistics.ties || 0;
                        totalStats.other += table.result_statistics.other || 0;
                    } else {
                        console.log(`[STATS DEBUG ${index}] No result_statistics for table:`, table.table_id);
                    }
                });

                console.log('[STATS] å…¨éƒ¨æ¡Œè™Ÿå¾Œç«¯çµ±è¨ˆ:', totalStats);
                console.log('[STATS] æœŸæœ›çš„ç¸½å’Œæ‡‰è©²æ¥è¿‘ç¸½å±€æ•¸:', elements.totalResults.textContent);
            }

            // æ›´æ–°é¡¯ç¤º
            elements.bankerWins.textContent = totalStats.banker_wins;
            elements.playerWins.textContent = totalStats.player_wins;
            elements.tieResults.textContent = totalStats.ties;
        }

        const elements = {
            status: document.getElementById('connectionStatus'),
            text: document.getElementById('connectionText'),
            connectBtn: document.getElementById('connectBtn'),
            eventsList: document.getElementById('eventsList'),
            gameTableBody: document.getElementById('gameTableBody'),
            totalResults: document.getElementById('totalResults'),
            lastUpdate: document.getElementById('lastUpdate'),
            errorCount: document.getElementById('errorCount'),
            connectionTime: document.getElementById('connectionTime'),
            monitoringDuration: document.getElementById('monitoringDuration'),
            currentTable: document.getElementById('currentTable'),
            activeTables: document.getElementById('activeTables'),
            bankerWins: document.getElementById('bankerWins'),
            playerWins: document.getElementById('playerWins'),
            tieResults: document.getElementById('tieResults'),
            tableSelect: document.getElementById('tableSelect'),
            tableTabs: document.getElementById('tableTabs'),
            tableOverview: document.getElementById('tableOverview'),
            detailView: document.getElementById('detailView'),
            panelTitle: document.getElementById('panelTitle'),
            overviewToggleText: document.getElementById('overviewToggleText')
        };

        // Phase classification function (matches server-side logic)
        function phaseOf(record) {
            const gameResult = record.gameResult || {};
            const result = (typeof gameResult === 'object' && gameResult.result !== undefined) ? gameResult.result : -1;
            const status = (record.game_payment_status_name || "").trim();

            if ([0, 1, 2, 3].includes(result)) {
                return 3;
            }
            if (['åœæ­¢', 'æ´¾å½©', 'çµæŸ'].some(keyword => status.includes(keyword))) {
                return 2;
            }
            return 1;
        }

        // Primary key function for upsert logic
        function getPrimaryKey(record) {
            const tableId = record.table_id || record.tableId || record.table;
            const roundId = record.round_id || record.roundId;

            if (tableId && roundId) {
                return `${tableId}:${parseInt(roundId)}`;
            }
            return null;
        }

        // Apply record with upsert logic
        function applyRecord(record) {
            const primaryKey = getPrimaryKey(record);

            if (!primaryKey) {
                // No primary key, add directly (fallback)
                addGameResultFromData(record);
                return true;
            }

            const phase = phaseOf(record);
            const existing = recordStore.get(primaryKey);

            if (!existing) {
                // New record
                recordStore.set(primaryKey, { phase, record });
                addGameResultFromData(record);
                return true;
            } else {
                // Update existing record (upsert logic)
                // Allow phase progression or same phase with different content
                if (phase >= existing.phase) {
                    recordStore.set(primaryKey, {
                        phase: Math.max(phase, existing.phase),
                        record
                    });
                    addGameResultFromData(record);
                    return true;
                }

                // Phase regression - ignore but log
                console.debug(`[UPSERT] Phase regression ignored: ${primaryKey} (${phase} < ${existing.phase})`);
                return false;
            }
        }

        // Smart refresh with throttling and backoff
        function scheduleNextRefresh() {
            if (refreshTimeoutId) {
                clearTimeout(refreshTimeoutId);
            }

            let delay;
            if (consecutiveErrors === 0) {
                // Normal case: 6-9 seconds random
                delay = 6000 + Math.random() * 3000;
            } else {
                // Backoff case: 15-20 seconds random
                delay = 15000 + Math.random() * 5000;
            }

            refreshTimeoutId = setTimeout(async () => {
                try {
                    await softRefresh();
                    consecutiveErrors = 0; // Reset on success
                    scheduleNextRefresh();
                } catch (error) {
                    consecutiveErrors++;
                    console.error('Soft refresh failed:', error);

                    // Check if page is stuck (extended timeout and better conditions)
                    const now = Date.now();
                    const timeSinceLastActivity = now - lastActivityTime;
                    const timeSincePageLoad = monitoringStartTime ? (now - monitoringStartTime) : 0;

                    // Only check for stuck page if:
                    // 1. Page has been running for at least 5 minutes
                    // 2. No activity for more than 10 minutes
                    // 3. Not currently connected or in error state
                    if (timeSincePageLoad > 300000 && // 5 minutes since page load
                        timeSinceLastActivity > 600000 && // 10 minutes of inactivity
                        !isConnected && // not currently connected
                        consecutiveErrors > 10) { // many consecutive errors
                        console.warn('Page appears stuck after extended inactivity, triggering reload');
                        console.log(`Time since last activity: ${(timeSinceLastActivity/1000/60).toFixed(1)} minutes`);
                        console.log(`Consecutive errors: ${consecutiveErrors}`);
                        window.location.reload();
                    } else {
                        scheduleNextRefresh();
                    }
                }
            }, delay);
        }

        // Soft refresh function
        async function softRefresh() {
            const response = await fetch('http://127.0.0.1:8000/api/latest?limit=30');
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            const records = data.records || [];

            let newCount = 0;
            records.forEach(record => {
                if (applyRecord(record)) {
                    newCount++;
                }
            });

            if (newCount > 0) {
                updateTotalGamesCount();
                updateResultStatistics();
                lastActivityTime = Date.now();
                elements.lastUpdate.textContent = new Date().toLocaleTimeString();
                updateGameTable();
            }

            return newCount;
        }

        async function fetchTables() {
            try {
                const response = await fetch('http://127.0.0.1:8000/api/tables/summary');
                const data = await response.json();
                availableTables = data.tables || [];
                updateTableSelector();
                updateTableTabs();
                updateOverview();
                updateTotalGamesCount();
                updateResultStatistics();
                elements.activeTables.textContent = data.total_tables || 0;
            } catch (error) {
                console.error('ç²å–æ¡Œè™Ÿå¤±æ•—:', error);
                addEvent('error', 'ç²å–æ¡Œè™Ÿå¤±æ•—', { error: error.message });
            }
        }

        function updateTableSelector() {
            const select = elements.tableSelect;
            select.innerHTML = '<option value="">å…¨éƒ¨æ¡Œè™Ÿ</option>';

            // æ ¹æ“šæ˜ å°„å¾Œçš„æ¡Œè™Ÿé€²è¡Œæ’åº
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const option = document.createElement('option');
                option.value = table.table_id; // ä¿æŒåŸå§‹æ¡Œè™Ÿä½œç‚º value (ç”¨æ–¼APIèª¿ç”¨)
                const displayTableId = mapTableId(table.table_id); // é¡¯ç¤ºæ˜ å°„å¾Œçš„æ¡Œè™Ÿ
                option.textContent = `${displayTableId} (${table.current_status})`;
                select.appendChild(option);
            });

            if (currentTableId) {
                select.value = currentTableId;
            }
        }

        function updateTableTabs() {
            const tabsContainer = elements.tableTabs;
            tabsContainer.innerHTML = '';
            
            // å…¨éƒ¨æ¨™ç±¤
            const allTab = document.createElement('div');
            allTab.className = `table-tab ${currentTableId === '' ? 'active' : ''}`;
            allTab.textContent = 'å…¨éƒ¨';
            allTab.onclick = () => switchToTable('');
            tabsContainer.appendChild(allTab);
            
            // å„æ¡Œæ¨™ç±¤ - æ ¹æ“šæ˜ å°„å¾Œçš„æ¡Œè™Ÿæ’åº
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const tab = document.createElement('div');
                tab.className = `table-tab ${currentTableId === table.table_id ? 'active' : ''}`;
                if (table.current_status === 'æŠ•æ³¨ä¸­' || table.current_status === 'é–‹çä¸­') {
                    tab.classList.add('has-activity');
                }
                const displayTableId = mapTableId(table.table_id); // é¡¯ç¤ºæ˜ å°„å¾Œçš„æ¡Œè™Ÿ
                tab.innerHTML = `
                    <div>${displayTableId}</div>
                    <div style="font-size: 0.7rem; color: #888;">${table.current_status}</div>
                `;
                tab.onclick = () => switchToTable(table.table_id);
                tabsContainer.appendChild(tab);
            });
        }

        function updateOverview() {
            const container = elements.tableOverview;
            container.innerHTML = '';

            // æ ¹æ“šæ˜ å°„å¾Œçš„æ¡Œè™Ÿæ’åº
            const sortedTables = [...availableTables].sort((a, b) => {
                const displayA = mapTableId(a.table_id);
                const displayB = mapTableId(b.table_id);
                return displayA.localeCompare(displayB, undefined, { numeric: true });
            });

            sortedTables.forEach(table => {
                const card = document.createElement('div');
                card.className = 'table-card';
                card.onclick = () => {
                    toggleOverview();
                    switchToTable(table.table_id);
                };

                const statusClass = getStatusBadgeClass(table.current_status);
                const displayTableId = mapTableId(table.table_id); // é¡¯ç¤ºæ˜ å°„å¾Œçš„æ¡Œè™Ÿ

                card.innerHTML = `
                    <div class="table-card-header">
                        <div class="table-card-title">${displayTableId}</div>
                        <span class="badge ${statusClass}">${table.current_status}</span>
                    </div>
                    <div class="table-card-content">
                        <div class="table-card-item"><strong>æœ€æ–°çµæœ:</strong> ${table.latest_result}</div>
                        <div class="table-card-item"><strong>æœ€æ–°å±€è™Ÿ:</strong> ${table.latest_round_id}</div>
                        <div class="table-card-item"><strong>ç¸½å±€æ•¸:</strong> ${table.total_games}</div>
                        ${table.result_statistics ? `
                            <div class="table-card-item">
                                <strong>å‹è² çµ±è¨ˆ:</strong>
                                <span class="result-stats">
                                    èŠ ${table.result_statistics.banker_wins} |
                                    é–’ ${table.result_statistics.player_wins} |
                                    å’Œ ${table.result_statistics.ties}
                                    ${table.result_statistics.other > 0 ? ` | å…¶ä»– ${table.result_statistics.other}` : ''}
                                </span>
                            </div>
                        ` : ''}
                        <div class="table-card-item"><strong>é–‹å±€æ™‚é–“:</strong> ${formatTime(table.game_start_time)}</div>
                    </div>
                `;

                container.appendChild(card);
            });
        }

        function switchTable() {
            const selectedTable = elements.tableSelect.value;
            switchToTable(selectedTable);
        }

        function switchToTable(tableId) {
            currentTableId = tableId;
            const displayTableId = tableId ? mapTableId(tableId) : 'å…¨éƒ¨';
            elements.currentTable.textContent = displayTableId;
            elements.tableSelect.value = tableId;

            // æ›´æ–°æ¨™ç±¤ç‹€æ…‹
            document.querySelectorAll('.table-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            if (tableId === '') {
                document.querySelector('.table-tab:first-child').classList.add('active');
                elements.panelTitle.textContent = 'éŠæˆ²çµæœ - å…¨éƒ¨æ¡Œè™Ÿ (æœ€æ–° 30 ç­†)';
            } else {
                // ä½¿ç”¨æ˜ å°„å¾Œçš„æ¡Œè™Ÿä¾†æŸ¥æ‰¾æ¨™ç±¤
                const mappedTableId = mapTableId(tableId);
                const activeTab = Array.from(document.querySelectorAll('.table-tab')).find(tab =>
                    tab.textContent.includes(mappedTableId)
                );
                if (activeTab) activeTab.classList.add('active');
                elements.panelTitle.textContent = `éŠæˆ²çµæœ - ${mappedTableId} (å…¨éƒ¨è³‡æ–™)`;
            }

            // æ›´æ–°ç¸½å±€æ•¸é¡¯ç¤º
            updateTotalGamesCount();
            updateResultStatistics();

            refreshCurrentTable();
        }

        async function refreshCurrentTable() {
            try {
                let url;
                if (currentTableId) {
                    // ç‰¹å®šæ¡Œè™Ÿé¡¯ç¤ºæ‰€æœ‰è³‡æ–™
                    url = `http://127.0.0.1:8000/api/tables/${currentTableId}?limit=1000`;
                } else {
                    // å…¨éƒ¨æ¡Œè™Ÿä»ä¿æŒ30ç­†é™åˆ¶
                    url = 'http://127.0.0.1:8000/api/latest?limit=30';
                }

                const response = await fetch(url);
                const data = await response.json();

                gameResults = [];
                const records = data.records || [];

                records.forEach(record => {
                    applyRecord(record);
                });

                updateGameTable();
                updateTotalGamesCount();
                updateResultStatistics();
                addEvent('system', `åˆ·æ–°${currentTableId || 'å…¨éƒ¨'}æ¡Œè™Ÿæ•¸æ“š`, {
                    table: currentTableId || 'å…¨éƒ¨',
                    count: records.length
                });

                lastActivityTime = Date.now();

            } catch (error) {
                console.error('åˆ·æ–°æ•¸æ“šå¤±æ•—:', error);
                addEvent('error', 'åˆ·æ–°æ•¸æ“šå¤±æ•—', { error: error.message });
                consecutiveErrors++;
            }
        }

        function toggleOverview() {
            isOverviewMode = !isOverviewMode;
            if (isOverviewMode) {
                elements.tableOverview.classList.remove('hidden');
                elements.detailView.classList.add('hidden');
                elements.overviewToggleText.textContent = 'è©³ç´°æ¨¡å¼';
                updateOverview();
            } else {
                elements.tableOverview.classList.add('hidden');
                elements.detailView.classList.remove('hidden');
                elements.overviewToggleText.textContent = 'ç¸½è¦½æ¨¡å¼';
            }
        }

        function refreshTables() {
            fetchTables();
            addEvent('system', 'æ‰‹å‹•åˆ·æ–°æ¡Œè™Ÿåˆ—è¡¨', {});
        }

        function toggleConnection() {
            if (isConnected) {
                disconnect();
            } else {
                connect();
            }
        }

        function connect() {
            const url = 'http://127.0.0.1:8000/api/stream?event_types=result,error,heartbeat';
            
            connectionStartTime = Date.now();
            firstResultTime = null;

            elements.status.className = 'status-indicator connecting';
            elements.text.textContent = 'é€£æ¥ä¸­...';
            elements.connectBtn.textContent = 'å–æ¶ˆ';

            eventSource = new EventSource(url);

            eventSource.onopen = function() {
                isConnected = true;
                elements.status.className = 'status-indicator connected';
                elements.text.textContent = 'å·²é€£æ¥';
                elements.connectBtn.textContent = 'æ–·é–‹';

                const connectTime = Date.now() - connectionStartTime;
                elements.connectionTime.textContent = connectTime + 'ms';

                // é‡ç½®ç¸½å±€æ•¸è¨ˆæ•¸å™¨å’Œæ´»å‹•æ™‚é–“
                recordStore.clear();
                updateTotalGamesCount();
                updateActivityTime(); // é‡ç½®æ´»å‹•æ™‚é–“
                consecutiveErrors = 0; // é‡ç½®éŒ¯èª¤è¨ˆæ•¸

                // é–‹å§‹ç›£æ§è¨ˆæ™‚
                monitoringStartTime = Date.now();
                startMonitoringTimer();

                addEvent('system', 'é€£æ¥å»ºç«‹', { url: url, connectTime: connectTime });

                // ç«‹å³æŠ½å–æ­·å²è³‡æ–™åˆ° recordStore
                // ä½¿ç”¨ softRefresh ç¢ºä¿æŠ“å–å…¨éƒ¨æ¡Œè™Ÿçš„æœ€æ–°è³‡æ–™
                softRefresh().then(() => {
                    updateTotalGamesCount();
                    updateGameTable();
                });

                // é–‹å§‹æ™ºèƒ½åˆ·æ–°
                scheduleNextRefresh(); // é–‹å§‹æ™ºèƒ½åˆ·æ–°èª¿åº¦
                fetchTables(); // ç«‹å³ç²å–ä¸€æ¬¡
            };

            eventSource.addEventListener('result', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleGameResult(data);
                } catch (e) {
                    console.error('è§£æçµæœæ•¸æ“šå¤±æ•—:', e);
                }
            });

            eventSource.addEventListener('error', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleError(data);
                } catch (e) {
                    console.error('è§£æéŒ¯èª¤æ•¸æ“šå¤±æ•—:', e);
                }
            });

            eventSource.addEventListener('heartbeat', function(event) {
                try {
                    const data = JSON.parse(event.data);
                    handleHeartbeat(data);
                } catch (e) {
                    console.error('è§£æå¿ƒè·³æ•¸æ“šå¤±æ•—:', e);
                }
            });

            eventSource.onmessage = function(event) {
                try {
                    const data = JSON.parse(event.data);
                    addEvent(data.event_type || 'message', 'é€šç”¨äº‹ä»¶', data);
                } catch (e) {
                    console.error('è§£æé€šç”¨äº‹ä»¶å¤±æ•—:', e);
                }
            };

            eventSource.onerror = function(event) {
                console.error('SSE é€£æ¥éŒ¯èª¤:', event);
                errorCount++;
                elements.errorCount.textContent = errorCount;
                
                if (!isConnected) {
                    elements.status.className = 'status-indicator';
                    elements.text.textContent = 'é€£æ¥å¤±æ•—';
                    elements.connectBtn.textContent = 'é‡é€£';
                }
                
                addEvent('error', 'é€£æ¥éŒ¯èª¤', { error: event });
            };
        }

        function disconnect() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }

            if (refreshTimeoutId) {
                clearTimeout(refreshTimeoutId);
                refreshTimeoutId = null;
            }

            isConnected = false;
            elements.status.className = 'status-indicator';
            elements.text.textContent = 'å·²æ–·é–‹';
            elements.connectBtn.textContent = 'é€£æ¥';

            // åœæ­¢ç›£æ§è¨ˆæ™‚
            stopMonitoringTimer();

            addEvent('system', 'é€£æ¥æ–·é–‹', {});
        }

        function handleGameResult(data) {
            let accepted = 0;
            let tables = new Set();

            const take = (r) => {
                try {
                    if (applyRecord(r)) {
                        accepted++;
                        // æå–æ¡Œè™Ÿè³‡è¨Š
                        const tableId = r.table_id || r.tableId || r.table;
                        if (tableId) tables.add(tableId);
                    }
                } catch (e) {
                    console.error('applyRecord failed:', e);
                }
            };

            // è§£æ payloadï¼Œé€ç­†æ¡ç´
            if (data && data.payload) {
                if (data.payload.record) {
                    take(data.payload.record);
                } else if (Array.isArray(data.payload.results)) {
                    data.payload.results.forEach(take);
                } else {
                    // æœ‰äº›æœå‹™æœƒç›´æ¥æŠŠ record æ”¾åœ¨ payload æ ¹ä¸Š
                    take(data.payload);
                }
            }

            // åªæœ‰çœŸçš„æœ‰è®Šæ›´ï¼Œæ‰æ›´æ–°çµ±è¨ˆèˆ‡ç•«é¢
            if (accepted > 0) {
                updateTotalGamesCount();
                updateResultStatistics();
                lastActivityTime = Date.now();
                elements.lastUpdate.textContent = new Date().toLocaleTimeString();
                updateGameTable();
            }

            // å»ºç«‹äº‹ä»¶è³‡è¨Š
            const eventPayload = {
                latency: data.latency_ms || 'N/A',
                accepted: accepted
            };

            // å¦‚æœæœ‰æ¡Œè™Ÿè³‡è¨Šï¼ŒåŠ å…¥åˆ° payload
            if (tables.size > 0) {
                eventPayload.tables = Array.from(tables).join(', ');
            }

            addEvent('result', 'æ”¶åˆ°éŠæˆ²çµæœ', eventPayload);

            // åˆ·æ–°æ¡Œè™Ÿåˆ—è¡¨ï¼ˆå¦‚æœæœ‰æ–°æ¡Œè™Ÿï¼‰
            setTimeout(fetchTables, 1000);
        }

        function handleError(data) {
            errorCount++;
            elements.errorCount.textContent = errorCount;
            addEvent('error', 'ç³»çµ±éŒ¯èª¤: ' + (data.payload?.error || 'æœªçŸ¥éŒ¯èª¤'), data.payload);
        }

        function handleHeartbeat(data) {
            addEvent('heartbeat', 'å¿ƒè·³æª¢æ¸¬', {
                timestamp: data.payload?.timestamp,
                latency: data.latency_ms || 'N/A'
            });
        }

        function addGameResultFromSSE(result) {
            // Use the new applyRecord function for deduplication
            if (applyRecord(result)) {
                lastActivityTime = Date.now();
                updateGameTable();
            }
        }

        function addGameResultFromData(result) {
            const roundId = result.round_id || result.roundId || result.id || 'N/A';
            const tableId = result.table_id || result.tableId || result.table || 'N/A';
            const startTime = result.game_start_time || result.openTime || result.start_time || 'N/A';

            // è™•ç†éŠæˆ²çµæœ
            let gameResult = 'é€²è¡Œä¸­';
            const gameResultData = result.gameResult || {};
            const status = (result.game_payment_status_name || '').trim();

            if (typeof gameResultData === 'object' && [1, 2, 3, 0].includes(gameResultData.result)) {
                const resultCode = gameResultData.result;
                if (resultCode === 1) gameResult = 'é–’å‹';
                else if (resultCode === 2) gameResult = 'å’Œå±€';
                else if (resultCode === 0) gameResult = 'èŠå‹';
                else if (resultCode === 3) gameResult = 'å–æ¶ˆ/ç„¡æ•ˆ';
            } else if (/(æ´¾å½©|å·²å½©|çµæŸ|finished)/i.test(status)) {
                gameResult = 'å·²æ´¾å½©'; // ç‹€æ…‹ fallbackï¼šè‹¥æ²’æœ‰å…·é«”çµæœä½†ç‹€æ…‹é¡¯ç¤ºå·²çµæŸ
            }

            const payload = {
                roundId,
                tableId,
                startTime,
                result: gameResult,
                resultCode: gameResultData.result || -1,
                status,
                raw: result
            };

            const idx = gameResults.findIndex(
                r => String(r.tableId) === String(tableId) && String(r.roundId) === String(roundId)
            );
            if (idx >= 0) {
                // æ›´æ–°èˆŠè³‡æ–™ï¼ˆä¾‹å¦‚æŠŠã€Œé€²è¡Œä¸­ã€æ›´æ–°æˆã€Œå·²æ´¾å½©ï¼èŠå‹ã€ï¼‰
                gameResults[idx] = {
                    roundId,
                    tableId,
                    startTime,
                    gameResult,
                    status: status || 'æœªçŸ¥',
                    timestamp: Date.now(),
                    raw: result  // Include raw data for points extraction
                };
            } else {
                // æ–°è³‡æ–™æ‰å¡åˆ°é™£åˆ—æœ€å‰é¢
                gameResults.unshift({
                    roundId,
                    tableId,
                    startTime,
                    gameResult,
                    status: status || 'æœªçŸ¥',
                    timestamp: Date.now(),
                    raw: result  // Include raw data for points extraction
                });
            }

            if (gameResults.length > 100) gameResults = gameResults.slice(0, 100);
        }

        function updateGameTable() {
            const tbody = elements.gameTableBody;
            tbody.innerHTML = '';

            if (gameResults.length === 0) {
                const row = tbody.insertRow();
                const cell = row.insertCell(0);
                cell.colSpan = 6;
                cell.style.textAlign = 'center';
                cell.style.color = '#888';
                const displayCurrentTableId = currentTableId ? mapTableId(currentTableId) : null;
                cell.textContent = displayCurrentTableId ? `${displayCurrentTableId} æ¡Œæš«ç„¡éŠæˆ²çµæœ` : 'æš«ç„¡éŠæˆ²çµæœ';
                return;
            }

            const filtered = gameResults.filter(r => !currentTableId || String(r.tableId) === String(currentTableId));

            // ä¾ã€Œå±€è™Ÿã€ç”±å¤§åˆ°å°ï¼ˆæœ€æ–°åœ¨å‰ï¼‰ï¼Œä¿è­‰åŒæ¡Œå…§æ’åºæ­£ç¢º
            filtered.sort((a, b) => (Number(b.roundId) || 0) - (Number(a.roundId) || 0));

            // æ ¹æ“šé¸æ“‡çš„æ¡Œè™Ÿæ±ºå®šé¡¯ç¤ºç­†æ•¸
            const limited = currentTableId ? filtered : filtered.slice(0, 30);
            const sortedResults = limited;

            sortedResults.forEach((result, index) => {
                const row = tbody.insertRow();

                // æ ¹æ“šç‹€æ…‹æ·»åŠ ä¸åŒçš„æ¨£å¼
                if (result.status === 'æŠ•æ³¨ä¸­') {
                    row.className = 'betting';
                } else if (result.status === 'é–‹çä¸­' || result.gameResult === 'é€²è¡Œä¸­') {
                    row.className = 'in-progress';
                } else if (index === 0 && (result.gameResult === 'èŠå‹' || result.gameResult === 'é–’å‹' || result.gameResult === 'å’Œå±€')) {
                    row.className = 'fresh'; // åªæœ‰æœ€æ–°ä¸€ç­†æ´¾å½©çµæœæ‰é¡¯ç¤ºç¶ è‰²æ•ˆæœ
                }

                row.insertCell(0).textContent = result.roundId;
                row.insertCell(1).textContent = mapTableId(result.tableId); // é¡¯ç¤ºæ˜ å°„å¾Œçš„æ¡Œè™Ÿ
                row.insertCell(2).textContent = formatTime(result.startTime);
                row.insertCell(3).textContent = result.gameResult;

                // æ–°å¢é»æ•¸æ¬„ä½
                const pointsCell = row.insertCell(4);
                let bankerPoints = null;
                let playerPoints = null;

                // Debug: log the data structure
                console.debug('[POINTS DEBUG]', 'result object:', result);
                console.debug('[POINTS DEBUG]', 'raw object:', result.raw);

                // å˜—è©¦å¾å¤šå€‹ä½ç½®æå–é»æ•¸ä¿¡æ¯
                if (result.raw) {
                    // æ–¹æ³•1: ç›´æ¥åœ¨ raw å°è±¡ä¸­æŸ¥æ‰¾ (æ¸¬è©¦æ•¸æ“šæ ¼å¼)
                    if (result.raw.bankerPoints !== undefined && result.raw.playerPoints !== undefined) {
                        bankerPoints = result.raw.bankerPoints;
                        playerPoints = result.raw.playerPoints;
                    }
                    // æ–¹æ³•2: åœ¨ gameResult å°è±¡ä¸­æŸ¥æ‰¾ (æ¸¬è©¦æ•¸æ“šæ ¼å¼)
                    else if (result.raw.gameResult && typeof result.raw.gameResult === 'object') {
                        const gr = result.raw.gameResult;
                        if (gr.bankerPoints !== undefined && gr.playerPoints !== undefined) {
                            bankerPoints = gr.bankerPoints;
                            playerPoints = gr.playerPoints;
                        }
                        // æ–¹æ³•3: çœŸå¯¦æ•¸æ“šæ ¼å¼ - player_point/banker_point
                        else if (gr.player_point !== undefined && gr.banker_point !== undefined &&
                                 gr.player_point !== "" && gr.banker_point !== "" &&
                                 gr.player_point !== "-" && gr.banker_point !== "-") {
                            playerPoints = gr.player_point;
                            bankerPoints = gr.banker_point;
                        }
                        // æ–¹æ³•4: çœŸå¯¦æ•¸æ“šæ ¼å¼ - maximum_points
                        else if (gr.player_maximum_points !== undefined && gr.banker_maximum_points !== undefined &&
                                 gr.player_maximum_points !== "" && gr.banker_maximum_points !== "" &&
                                 gr.player_maximum_points !== "-" && gr.banker_maximum_points !== "-") {
                            playerPoints = gr.player_maximum_points;
                            bankerPoints = gr.banker_maximum_points;
                        }
                    }
                }

                if (bankerPoints !== null && playerPoints !== null) {
                    pointsCell.innerHTML = `
                        <div class="points-display">
                            <span class="banker-points">${bankerPoints}</span>
                            <span class="points-separator">/</span>
                            <span class="player-points">${playerPoints}</span>
                        </div>
                    `;
                } else {
                    pointsCell.textContent = 'ç­‰å¾…é»æ•¸';
                    pointsCell.style.color = '#888';
                    pointsCell.style.fontSize = '0.85rem';
                }

                const statusCell = row.insertCell(5);
                const statusBadge = document.createElement('span');
                statusBadge.className = 'badge ' + getStatusBadgeClass(result.status);
                statusBadge.textContent = result.status;
                statusCell.appendChild(statusBadge);
            });
        }

        function formatTime(timeStr) {
            if (!timeStr || timeStr === 'N/A') return 'N/A';
            try {
                if (typeof timeStr === 'string' && timeStr.includes(':')) {
                    return timeStr; // å·²ç¶“æ˜¯æ™‚é–“æ ¼å¼
                }
                const date = new Date(timeStr);
                return date.toLocaleTimeString();
            } catch (e) {
                return timeStr;
            }
        }

        function getStatusBadgeClass(status) {
            if (status === 'å·²çµæŸ' || status === 'finished') return 'badge-success';
            if (status === 'æŠ•æ³¨ä¸­') return 'badge-betting';
            if (status === 'é–‹çä¸­' || status === 'é€²è¡Œä¸­' || status === 'running') return 'badge-in-progress';
            if (status === 'éŒ¯èª¤' || status === 'error') return 'badge-danger';
            return 'badge-warning';
        }

        function formatEventPayload(type, payload) {
            if (!payload || Object.keys(payload).length === 0) return '';

            switch (type) {
                case 'result':
                    return `
                        <div class="event-details">
                            ${payload.latency !== 'N/A' ? `<span class="detail-item">å»¶é²: ${payload.latency}ms</span>` : ''}
                            ${payload.accepted ? `<span class="detail-item">æ¥å—: ${payload.accepted} ç­†</span>` : ''}
                            ${payload.tables ? `<span class="detail-item">æ¡Œè™Ÿ: ${payload.tables.split(', ').map(t => mapTableId(t)).join(', ')}</span>` : ''}
                        </div>
                    `;

                case 'system':
                    let systemDetails = '';
                    if (payload.table) {
                        const displayTable = payload.table === 'å…¨éƒ¨' ? 'å…¨éƒ¨' : mapTableId(payload.table);
                        systemDetails += `<span class="detail-item">æ¡Œè™Ÿ: ${displayTable}</span>`;
                    }
                    if (payload.count) systemDetails += `<span class="detail-item">æ•¸é‡: ${payload.count}</span>`;
                    if (payload.url) systemDetails += `<span class="detail-item">é€£æ¥: ${payload.url}</span>`;
                    if (payload.connectTime) systemDetails += `<span class="detail-item">è€—æ™‚: ${payload.connectTime}ms</span>`;
                    return systemDetails ? `<div class="event-details">${systemDetails}</div>` : '';

                case 'heartbeat':
                    let heartbeatDetails = '';
                    if (payload.timestamp) {
                        try {
                            const time = new Date(payload.timestamp * 1000).toLocaleTimeString();
                            heartbeatDetails += `<span class="detail-item">æ™‚é–“: ${time}</span>`;
                        } catch (e) {
                            heartbeatDetails += `<span class="detail-item">æ™‚é–“: ${payload.timestamp}</span>`;
                        }
                    }
                    if (payload.latency && payload.latency !== 'N/A') {
                        heartbeatDetails += `<span class="detail-item">å»¶é²: ${payload.latency}ms</span>`;
                    }
                    return heartbeatDetails ? `<div class="event-details">${heartbeatDetails}</div>` : '';

                case 'error':
                    return `
                        <div class="event-details error-details">
                            ${payload.error ? `<span class="detail-item">éŒ¯èª¤: ${payload.error}</span>` : ''}
                        </div>
                    `;

                default:
                    // å°æ–¼å…¶ä»–é¡å‹ï¼Œç°¡åŒ–é¡¯ç¤ºé‡è¦å­—æ®µ
                    const importantFields = ['status', 'count', 'message', 'success'];
                    let defaultDetails = '';
                    for (const field of importantFields) {
                        if (payload[field] !== undefined) {
                            defaultDetails += `<span class="detail-item">${field}: ${payload[field]}</span>`;
                        }
                    }
                    return defaultDetails ? `<div class="event-details">${defaultDetails}</div>` : '';
            }
        }

        function addEvent(type, title, payload) {
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item ' + type;

            const now = new Date();
            const timeStr = now.toLocaleTimeString();

            eventItem.innerHTML = `
                <div class="event-header">
                    <span class="event-type">${type}</span>
                    <span class="event-time">${timeStr}</span>
                </div>
                <div class="event-content">
                    <strong>${title}</strong>
                    ${formatEventPayload(type, payload)}
                </div>
            `;

            elements.eventsList.insertBefore(eventItem, elements.eventsList.firstChild);

            // åªä¿ç•™æœ€æ–° 20 å€‹äº‹ä»¶
            while (elements.eventsList.children.length > 20) {
                elements.eventsList.removeChild(elements.eventsList.lastChild);
            }
        }

        // ç¢ºèªæ¸…ç©ºçµæœ
        function confirmClearResults() {
            if (confirm('ğŸ—‘ï¸ ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰çµæœå—ï¼Ÿ\n\næ­¤æ“ä½œå°‡æœƒï¼š\nâ€¢ æ¸…é™¤æ‰€æœ‰éŠæˆ²çµæœ\nâ€¢ æ¸…ç©ºäº‹ä»¶æ—¥èªŒ\n\næ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) {
                clearResults();
                addEvent('system', 'ç”¨æˆ¶æ‰‹å‹•æ¸…ç©ºçµæœ', {
                    timestamp: new Date().toLocaleString(),
                    action: 'clear_results'
                });
            }
        }

        function clearResults() {
            gameResults = [];
            updateGameTable();
            elements.eventsList.innerHTML = '<div style="text-align: center; color: #888;">äº‹ä»¶å·²æ¸…ç©º</div>';
        }

        // ç¢ºèªé‡ç½®çµ±è¨ˆ
        function confirmResetStats() {
            if (confirm('ğŸ“Š ç¢ºå®šè¦é‡ç½®æ‰€æœ‰çµ±è¨ˆå—ï¼Ÿ\n\næ­¤æ“ä½œå°‡æœƒï¼š\nâ€¢ é‡ç½®éŒ¯èª¤è¨ˆæ•¸\nâ€¢ æ¸…ç©ºæ‰€æœ‰éŠæˆ²çµæœ\nâ€¢ é‡ç½®ç›£æ§æ™‚é–“\nâ€¢ æ¸…ç©ºäº‹ä»¶è¨˜éŒ„\n\næ­¤æ“ä½œç„¡æ³•å¾©åŸï¼')) {
                resetStats();
                addEvent('system', 'ç”¨æˆ¶æ‰‹å‹•é‡ç½®çµ±è¨ˆ', {
                    timestamp: new Date().toLocaleString(),
                    action: 'reset_stats'
                });
            }
        }

        function resetStats() {
            errorCount = 0;
            resultTimes = [];
            firstResultTime = null;
            gameResults = [];
            recordStore.clear();

            updateTotalGamesCount();
            updateResultStatistics();
            elements.errorCount.textContent = '0';
            elements.lastUpdate.textContent = '--';

            // é‡ç½®ç›£æ§æ™‚é–“
            resetMonitoringTimer();

            updateGameTable();
            clearResults();
        }

        // æ ¼å¼åŒ–æ™‚é–“é•·åº¦
        function formatDuration(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) {
                return `${days}å¤© ${hours % 24}æ™‚ ${minutes % 60}åˆ†`;
            } else if (hours > 0) {
                return `${hours}æ™‚ ${minutes % 60}åˆ† ${seconds % 60}ç§’`;
            } else if (minutes > 0) {
                return `${minutes}åˆ† ${seconds % 60}ç§’`;
            } else {
                return `${seconds}ç§’`;
            }
        }

        // æ›´æ–°ç›£æ§æ™‚é•·
        function updateMonitoringDuration() {
            if (monitoringStartTime === null) {
                elements.monitoringDuration.textContent = '--';
                return;
            }
            const duration = Date.now() - monitoringStartTime;
            elements.monitoringDuration.textContent = formatDuration(duration);
        }

        // å•Ÿå‹•ç›£æ§æ™‚é•·å®šæ™‚å™¨
        function startMonitoringTimer() {
            if (monitoringDurationInterval) {
                clearInterval(monitoringDurationInterval);
            }
            monitoringDurationInterval = setInterval(updateMonitoringDuration, 1000);
            updateMonitoringDuration(); // ç«‹å³æ›´æ–°ä¸€æ¬¡
        }

        // é‡ç½®ç›£æ§æ™‚é–“ï¼ˆåªåœ¨é€£æ¥æ™‚ä½¿ç”¨ï¼‰
        function resetMonitoringTimer() {
            if (isConnected) {
                monitoringStartTime = Date.now();
            } else {
                monitoringStartTime = null;
            }
            updateMonitoringDuration();
        }

        // åœæ­¢ç›£æ§è¨ˆæ™‚å™¨
        function stopMonitoringTimer() {
            if (monitoringDurationInterval) {
                clearInterval(monitoringDurationInterval);
                monitoringDurationInterval = null;
            }
            monitoringStartTime = null;
            updateMonitoringDuration();
        }

        // åˆå§‹åŒ–ç›£æ§æ™‚é•·é¡¯ç¤ºï¼ˆç­‰å¾…é€£æ¥ï¼‰
        updateMonitoringDuration();

        // ===== è³‡æ–™å°å‡ºåŠŸèƒ½ =====

        // å°å‡ºç›¸é—œè®Šé‡
        let exportPreviewTimer = null;
        const INGEST_KEY = 'baccaratt9webapi'; // å¾ç’°å¢ƒç²å–æˆ–é…ç½®

        // æ‰“é–‹å°å‡ºæ¨¡æ…‹æ¡†
        function openExportModal() {
            const modal = document.getElementById('exportModal');
            modal.classList.remove('hidden');

            // åˆå§‹åŒ–å°å‡ºé¸é …
            initializeExportOptions();

            // æ›´æ–°é è¦½
            updateExportPreview();

            // æ·»åŠ äº‹ä»¶ç›£è½å™¨
            addExportEventListeners();

            addEvent('system', 'æ‰“é–‹å°å‡ºé¢æ¿', {});
        }

        // é—œé–‰å°å‡ºæ¨¡æ…‹æ¡†
        function closeExportModal() {
            const modal = document.getElementById('exportModal');
            modal.classList.add('hidden');

            // æ¸…ç†å®šæ™‚å™¨
            if (exportPreviewTimer) {
                clearTimeout(exportPreviewTimer);
                exportPreviewTimer = null;
            }

            // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
            resetExportButton();
        }

        // åˆå§‹åŒ–å°å‡ºé¸é …
        function initializeExportOptions() {
            // è¨­ç½®é»˜èªæ—¥æœŸï¼ˆä»Šå¤©ï¼‰
            const today = new Date();
            const todayString = today.toISOString().split('T')[0];
            document.getElementById('exportEndDate').value = todayString;

            // è¨­ç½®é»˜èªé–‹å§‹æ—¥æœŸï¼ˆä¸€é€±å‰ï¼‰
            const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
            const weekAgoString = weekAgo.toISOString().split('T')[0];
            document.getElementById('exportStartDate').value = weekAgoString;

            // å¡«å……æ¡Œè™Ÿé¸é …
            const tableSelect = document.getElementById('exportTableId');
            tableSelect.innerHTML = '<option value="">å…¨éƒ¨æ¡Œè™Ÿ</option>';

            // ä½¿ç”¨ç¾æœ‰çš„ availableTables æ•¸æ“š
            availableTables.forEach(table => {
                const option = document.createElement('option');
                option.value = table.table_id;
                const displayTableId = mapTableId(table.table_id);
                option.textContent = `${displayTableId} (${table.total_games} å±€)`;
                tableSelect.appendChild(option);
            });

            // å¦‚æœç•¶å‰æœ‰é¸æ“‡æ¡Œè™Ÿï¼Œè¨­ç‚ºé»˜èª
            if (currentTableId) {
                tableSelect.value = currentTableId;
            }
        }

        // æ·»åŠ äº‹ä»¶ç›£è½å™¨
        function addExportEventListeners() {
            // ç›£è½æ‰€æœ‰ç¯©é¸æ¢ä»¶è®Šæ›´
            const filterInputs = [
                'exportTableId', 'exportStartDate', 'exportEndDate',
                'exportStatus', 'exportLimit'
            ];

            filterInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    input.addEventListener('change', debounceUpdatePreview);
                }
            });

            // ç›£è½æ ¼å¼é¸æ“‡è®Šæ›´
            const formatRadios = document.querySelectorAll('input[name="exportFormat"]');
            formatRadios.forEach(radio => {
                radio.addEventListener('change', updateExportPreview);
            });
        }

        // é˜²æŠ–æ›´æ–°é è¦½
        function debounceUpdatePreview() {
            if (exportPreviewTimer) {
                clearTimeout(exportPreviewTimer);
            }
            exportPreviewTimer = setTimeout(updateExportPreview, 300);
        }

        // æ›´æ–°å°å‡ºé è¦½
        async function updateExportPreview() {
            try {
                const filters = getExportFilters();
                const format = getSelectedFormat();

                // æ§‹å»ºé è¦½è«‹æ±‚URLï¼ˆåªç²å–è¨ˆæ•¸ï¼Œä¸å¯¦éš›å°å‡ºï¼‰
                const params = new URLSearchParams();
                if (filters.table_id) params.set('table_id', filters.table_id);
                if (filters.start_date) params.set('start_date', filters.start_date);
                if (filters.end_date) params.set('end_date', filters.end_date);
                if (filters.status_filter) params.set('status_filter', filters.status_filter);
                if (filters.limit) params.set('limit', filters.limit);

                // ä½¿ç”¨ç¾æœ‰çš„APIç²å–è¨˜éŒ„æ•¸é‡é ä¼°
                let apiUrl;
                if (filters.table_id) {
                    apiUrl = `http://127.0.0.1:8000/api/tables/${filters.table_id}?limit=1`;
                } else {
                    apiUrl = 'http://127.0.0.1:8000/api/latest?limit=1';
                }

                const response = await fetch(apiUrl);
                if (response.ok) {
                    const data = await response.json();
                    let estimatedCount = data.total || 0;

                    // å¦‚æœæœ‰é™åˆ¶æ¢ä»¶ï¼Œèª¿æ•´é ä¼°
                    if (filters.limit && filters.limit < estimatedCount) {
                        estimatedCount = filters.limit;
                    }

                    // æ›´æ–°é è¦½é¡¯ç¤º
                    updatePreviewDisplay(estimatedCount, filters, format);
                } else {
                    updatePreviewDisplay(0, filters, format);
                }

            } catch (error) {
                console.error('æ›´æ–°å°å‡ºé è¦½å¤±æ•—:', error);
                updatePreviewDisplay(0, {}, getSelectedFormat());
            }
        }

        // æ›´æ–°é è¦½é¡¯ç¤º
        function updatePreviewDisplay(count, filters, format) {
            // æ›´æ–°è¨˜éŒ„æ•¸é‡
            document.getElementById('exportPreviewCount').textContent = `${count.toLocaleString()} ç­†è¨˜éŒ„`;

            // æ›´æ–°æ¡Œè™Ÿç¯„åœ
            let tableRange = 'å…¨éƒ¨æ¡Œè™Ÿ';
            if (filters.table_id) {
                tableRange = mapTableId(filters.table_id);
            } else if (availableTables.length > 0) {
                const tableNames = availableTables.map(t => mapTableId(t.table_id)).sort();
                if (tableNames.length <= 3) {
                    tableRange = tableNames.join(', ');
                } else {
                    tableRange = `${tableNames[0]} ~ ${tableNames[tableNames.length - 1]} ç­‰ ${tableNames.length} æ¡Œ`;
                }
            }
            document.getElementById('exportPreviewTables').textContent = tableRange;

            // ä¼°ç®—æª”æ¡ˆå¤§å°ï¼ˆç²—ç•¥ä¼°ç®—ï¼‰
            let sizeEstimate = 'è¨ˆç®—ä¸­...';
            if (count > 0) {
                const bytesPerRecord = format === 'json' ? 800 : format === 'excel' ? 200 : 150;
                const totalBytes = count * bytesPerRecord;

                if (totalBytes < 1024) {
                    sizeEstimate = `${totalBytes} B`;
                } else if (totalBytes < 1024 * 1024) {
                    sizeEstimate = `${(totalBytes / 1024).toFixed(1)} KB`;
                } else {
                    sizeEstimate = `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;
                }
            } else {
                sizeEstimate = '0 B';
            }
            document.getElementById('exportPreviewSize').textContent = sizeEstimate;
        }

        // ç²å–å°å‡ºç¯©é¸æ¢ä»¶
        function getExportFilters() {
            return {
                table_id: document.getElementById('exportTableId').value || null,
                start_date: document.getElementById('exportStartDate').value || null,
                end_date: document.getElementById('exportEndDate').value || null,
                status_filter: document.getElementById('exportStatus').value || null,
                limit: document.getElementById('exportLimit').value ? parseInt(document.getElementById('exportLimit').value) : null
            };
        }

        // ç²å–é¸æ“‡çš„æ ¼å¼
        function getSelectedFormat() {
            const formatRadio = document.querySelector('input[name="exportFormat"]:checked');
            return formatRadio ? formatRadio.value : 'json';
        }

        // é–‹å§‹å°å‡º
        async function startExport() {
            const exportButton = document.getElementById('exportButton');
            const exportButtonText = document.getElementById('exportButtonText');
            const exportButtonSpinner = document.getElementById('exportButtonSpinner');

            try {
                // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                exportButton.disabled = true;
                exportButtonText.textContent = 'å°å‡ºä¸­...';
                exportButtonSpinner.classList.remove('hidden');

                const filters = getExportFilters();
                const format = getSelectedFormat();

                addEvent('system', 'é–‹å§‹å°å‡ºè³‡æ–™', {
                    format: format.toUpperCase(),
                    table: filters.table_id ? mapTableId(filters.table_id) : 'å…¨éƒ¨',
                    limit: filters.limit || 'ç„¡é™åˆ¶'
                });

                // æ§‹å»ºAPIè«‹æ±‚URL
                const params = new URLSearchParams();
                if (filters.table_id) params.set('table_id', filters.table_id);
                if (filters.start_date) params.set('start_date', filters.start_date);
                if (filters.end_date) params.set('end_date', filters.end_date);
                if (filters.status_filter) params.set('status_filter', filters.status_filter);
                if (filters.limit) params.set('limit', filters.limit.toString());

                const apiUrl = `http://127.0.0.1:8000/api/export/${format}?${params.toString()}`;

                // ç™¼é€å°å‡ºè«‹æ±‚
                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'x-ingest-key': INGEST_KEY
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text().catch(() => 'æœªçŸ¥éŒ¯èª¤');
                    throw new Error(`å°å‡ºå¤±æ•—: ${response.status} ${response.statusText} - ${errorText}`);
                }

                // ç²å–æª”æ¡ˆåç¨±
                const contentDisposition = response.headers.get('content-disposition');
                let filename = `t9_export_${format}_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.${format}`;
                if (contentDisposition && contentDisposition.includes('filename=')) {
                    filename = contentDisposition.split('filename=')[1].replace(/"/g, '');
                }

                // ä¸‹è¼‰æª”æ¡ˆ
                const blob = await response.blob();
                const downloadUrl = window.URL.createObjectURL(blob);
                const downloadLink = document.createElement('a');
                downloadLink.href = downloadUrl;
                downloadLink.download = filename;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                window.URL.revokeObjectURL(downloadUrl);

                // ç²å–å°å‡ºçµ±è¨ˆ
                const totalRecords = response.headers.get('X-Total-Records') || 'æœªçŸ¥';
                const fileSize = (blob.size / 1024).toFixed(1);

                addEvent('system', 'å°å‡ºå®Œæˆ', {
                    format: format.toUpperCase(),
                    filename: filename,
                    records: totalRecords,
                    size: `${fileSize} KB`
                });

                // é‡ç½®æŒ‰éˆ•ç‹€æ…‹ä¸¦é—œé–‰æ¨¡æ…‹æ¡†
                resetExportButton();
                setTimeout(() => {
                    closeExportModal();
                }, 500); // å»¶é²500msè®“ç”¨æˆ¶çœ‹åˆ°æˆåŠŸç‹€æ…‹

            } catch (error) {
                console.error('å°å‡ºéŒ¯èª¤:', error);
                addEvent('error', 'å°å‡ºå¤±æ•—', { error: error.message });

                // ç¢ºä¿é‡ç½®æŒ‰éˆ•ç‹€æ…‹
                resetExportButton();
            } finally {
                // ç„¡è«–æˆåŠŸæˆ–å¤±æ•—éƒ½ç¢ºä¿é‡ç½®æŒ‰éˆ•ç‹€æ…‹
                setTimeout(() => {
                    resetExportButton();
                }, 100);
            }
        }

        // é‡ç½®å°å‡ºæŒ‰éˆ•ç‹€æ…‹
        function resetExportButton() {
            const exportButton = document.getElementById('exportButton');
            const exportButtonText = document.getElementById('exportButtonText');
            const exportButtonSpinner = document.getElementById('exportButtonSpinner');

            exportButton.disabled = false;
            exportButtonText.textContent = 'é–‹å§‹å°å‡º';
            exportButtonSpinner.classList.add('hidden');
        }

        // æ¨¡æ…‹æ¡†é»æ“Šå¤–éƒ¨é—œé–‰
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('exportModal');
            if (event.target === modal) {
                closeExportModal();
            }
        });

        // ESCéµé—œé–‰æ¨¡æ…‹æ¡†
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const modal = document.getElementById('exportModal');
                if (!modal.classList.contains('hidden')) {
                    closeExportModal();
                }
            }
        });

        // è‡ªå‹•é€£æ¥
        setTimeout(() => {
            if (!isConnected) {
                connect();
            }
        }, 1000);
    </script>
</body>
</html>